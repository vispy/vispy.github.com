tutorial/gl/cube
----------------




.. code-block:: python
    
    cube_fragment = 
    uniform sampler2D u_texture;
    varying vec2 v_texcoord;
    void main()
    {
        gl_FragColor = texture2D(u_texture, v_texcoord);
    }
    """
    
    
    def display():
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
        gl.glDrawElements(
            gl.GL_TRIANGLES, icube_data.size, gl.GL_UNSIGNED_INT, None)
        glut.glutSwapBuffers()
    
    
    def reshape(width, height):
        gl.glViewport(0, 0, width, height)
        projection = perspective(35.0, width / float(height), 2.0, 10.0)
        loc = gl.glGetUniformLocation(cube, "u_projection")
        gl.glUniformMatrix4fv(loc, 1, False, projection)
    
    
    def keyboard(key, x, y):
        if key == '\033':
            sys.exit()
    
    
    def timer(fps):
        global theta, phi
        theta += .5
        phi += .5
        model = np.eye(4, dtype=np.float32)
        rotate(model, theta, 0, 0, 1)
        rotate(model, phi, 0, 1, 0)
        loc = gl.glGetUniformLocation(cube, "u_model")
        gl.glUniformMatrix4fv(loc, 1, False, model)
        glut.glutTimerFunc(1000 / fps, timer, fps)
        glut.glutPostRedisplay()
    
    
    # GLUT init
    # --------------------------------------
    glut.glutInit()
    glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)
    glut.glutCreateWindow('Rotating cube (GL version)')
    glut.glutReshapeWindow(512, 512)
    glut.glutReshapeFunc(reshape)
    glut.glutDisplayFunc(display)
    glut.glutKeyboardFunc(keyboard)
    glut.glutTimerFunc(1000 / 60, timer, 60)
    
    # Build & activate cube program
    # --------------------------------------
    cube = gl.glCreateProgram()
    vertex = gl.glCreateShader(gl.GL_VERTEX_SHADER)
    fragment = gl.glCreateShader(gl.GL_FRAGMENT_SHADER)
    gl.glShaderSource(vertex, cube_vertex)
    gl.glShaderSource(fragment, cube_fragment)
    gl.glCompileShader(vertex)
    gl.glCompileShader(fragment)
    gl.glAttachShader(cube, vertex)
    gl.glAttachShader(cube, fragment)
    gl.glLinkProgram(cube)
    gl.glDetachShader(cube, vertex)
    gl.glDetachShader(cube, fragment)
    gl.glUseProgram(cube)
    
    # Get data & build cube buffers
    # --------------------------------------
    vcube_data, icube_data = makecube()
    vcube = gl.glGenBuffers(1)
    gl.glBindBuffer(gl.GL_ARRAY_BUFFER, vcube)
    gl.glBufferData(
        gl.GL_ARRAY_BUFFER, vcube_data.nbytes, vcube_data, gl.GL_STATIC_DRAW)
    icube = gl.glGenBuffers(1)
    gl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, icube)
    gl.glBufferData(gl.GL_ELEMENT_ARRAY_BUFFER,
                    icube_data.nbytes, icube_data, gl.GL_STATIC_DRAW)
    
    # Bind cube attributes
    # --------------------------------------
    stride = vcube_data.strides[0]
    offset = ctypes.c_void_p(0)
    loc = gl.glGetAttribLocation(cube, "a_position")
    gl.glEnableVertexAttribArray(loc)
    gl.glVertexAttribPointer(loc, 3, gl.GL_FLOAT, False, stride, offset)
    
    offset = ctypes.c_void_p(vcube_data.dtype["a_position"].itemsize)
    loc = gl.glGetAttribLocation(cube, "a_texcoord")
    gl.glEnableVertexAttribArray(loc)
    gl.glVertexAttribPointer(loc, 2, gl.GL_FLOAT, False, stride, offset)
    
    # Create & bind cube texture
    # --------------------------------------
    crate = checkerboard()
    texture = gl.glGenTextures(1)
    gl.glTexParameterf(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_LINEAR)
    gl.glTexParameterf(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_LINEAR)
    gl.glTexParameterf(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_CLAMP_TO_EDGE)
    gl.glTexParameterf(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_CLAMP_TO_EDGE)
    gl.glTexImage2D(gl.GL_TEXTURE_2D, 0, gl.GL_INTENSITY,
                    crate.shape[1], crate.shape[0],
                    0, gl.GL_RED, gl.GL_UNSIGNED_BYTE, crate)
    loc = gl.glGetUniformLocation(cube, "u_texture")
    gl.glUniform1i(loc, texture)
    gl.glBindTexture(gl.GL_TEXTURE_2D, 0)
    
    # Create & bind cube matrices
    # --------------------------------------
    view = np.eye(4, dtype=np.float32)
    model = np.eye(4, dtype=np.float32)
    projection = np.eye(4, dtype=np.float32)
    translate(view, 0, 0, -7)
    phi, theta = 60, 20
    rotate(model, theta, 0, 0, 1)
    rotate(model, phi, 0, 1, 0)
    loc = gl.glGetUniformLocation(cube, "u_model")
    gl.glUniformMatrix4fv(loc, 1, False, model)
    loc = gl.glGetUniformLocation(cube, "u_view")
    gl.glUniformMatrix4fv(loc, 1, False, view)
    loc = gl.glGetUniformLocation(cube, "u_projection")
    gl.glUniformMatrix4fv(loc, 1, False, projection)
    
    # OpenGL initalization
    # --------------------------------------
    gl.glClearColor(0.30, 0.30, 0.35, 1.00)
    gl.glEnable(gl.GL_DEPTH_TEST)
    
    # Enter mainloop
    # --------------------------------------
    glut.glutMainLoop()
