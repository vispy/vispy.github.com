
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Scenegraph &mdash; VisPy</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootswatch-3.3.4/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/css/font-mfizz.css" type="text/css" />
    <link rel="stylesheet" href="_static/css/font-awesome.css" type="text/css" />
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="VisPy" href="index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html"><img src="_static/vispy-text-white.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
                <li><a href="documentation.html">Documentation</a></li>
                <li><a href="gallery.html">Gallery</a></li>
                <li><a href="resources.html">Resources</a></li>
                <li><a href="community.html">Community</a></li>
                <li><a href="news.html">News</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#"> <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Scenegraph</a><ul>
<li><a class="reference internal" href="#overview">Overview</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#module-vispy.scene.cameras">vispy.scene.cameras</a></li>
<li><a class="reference internal" href="#module-vispy.scene.canvas">vispy.scene.canvas</a></li>
<li><a class="reference internal" href="#module-vispy.scene.node">vispy.scene.node</a></li>
<li><a class="reference internal" href="#module-vispy.scene.events">vispy.scene.events</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#module-vispy.scene.visuals">vispy.scene.visuals</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#module-vispy.scene.widgets">vispy.scene.widgets</a><ul>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45168532-1', 'vispy.org');
  ga('send', 'pageview');
</script>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="module-vispy.scene">
<span id="scenegraph"></span><h1>Scenegraph<a class="headerlink" href="#module-vispy.scene" title="Permalink to this headline">¶</a></h1>
<p>The vispy.scene subpackage provides high-level, flexible, and easy to use
functionality for creating scenes composed of multiple visual objects.</p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Scenegraphs are a commonly used system for describing a scene as a 
hierarchy of visual objects. Users need only create these visual objects and 
specify their location in the scene, and the scenegraph system will 
automatically draw the entire scene whenever an update is required.</p>
<p>Using the vispy scenegraph requires only a few steps:</p>
<ol class="arabic simple">
<li>Create a SceneCanvas to display the scene. This object has a <cite>scene</cite> 
property that is the top-level Node in the scene.</li>
<li>Create one or more Node instances (see vispy.scene.visuals)</li>
<li>Add these Node instances to the scene by making them children of 
canvas.scene, or children of other nodes that are already in the scene.</li>
</ol>
<p>For more information see:</p>
<ul class="simple">
<li>complete scenegraph documentation</li>
<li>scene examples</li>
<li>scene API reference</li>
</ul>
<dl class="class">
<dt id="vispy.scene.SceneCanvas">
<em class="property">class </em><code class="descclassname">vispy.scene.</code><code class="descname">SceneCanvas</code><span class="sig-paren">(</span><em>title='Vispy canvas'</em>, <em>size=(800</em>, <em>600)</em>, <em>position=None</em>, <em>show=False</em>, <em>autoswap=True</em>, <em>app=None</em>, <em>create_native=True</em>, <em>vsync=False</em>, <em>resizable=True</em>, <em>decorate=True</em>, <em>fullscreen=False</em>, <em>config=None</em>, <em>shared=None</em>, <em>keys=None</em>, <em>parent=None</em>, <em>dpi=None</em>, <em>always_on_top=False</em>, <em>px_scale=1</em>, <em>bgcolor='black'</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.SceneCanvas" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.app.canvas.Canvas</span></code></p>
<p>A Canvas that automatically draws the contents of a scene</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>title</strong> : str</p>
<blockquote>
<div><p>The widget title</p>
</div></blockquote>
<p><strong>size</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the window.</p>
</div></blockquote>
<p><strong>position</strong> : (x, y)</p>
<blockquote>
<div><p>The position of the window in screen coordinates.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Whether to show the widget immediately. Default False.</p>
</div></blockquote>
<p><strong>autoswap</strong> : bool</p>
<blockquote>
<div><p>Whether to swap the buffers automatically after a draw event.
Default True. If True, the <code class="docutils literal"><span class="pre">swap_buffers</span></code> Canvas method will
be called last (by default) by the <code class="docutils literal"><span class="pre">canvas.draw</span></code> event handler.</p>
</div></blockquote>
<p><strong>app</strong> : Application | str</p>
<blockquote>
<div><p>Give vispy Application instance to use as a backend.
(vispy.app is used by default.) If str, then an application
using the chosen backend (e.g., 'pyglet') will be created.
Note the canvas application can be accessed at <code class="docutils literal"><span class="pre">canvas.app</span></code>.</p>
</div></blockquote>
<p><strong>create_native</strong> : bool</p>
<blockquote>
<div><p>Whether to create the widget immediately. Default True.</p>
</div></blockquote>
<p><strong>vsync</strong> : bool</p>
<blockquote>
<div><p>Enable vertical synchronization.</p>
</div></blockquote>
<p><strong>resizable</strong> : bool</p>
<blockquote>
<div><p>Allow the window to be resized.</p>
</div></blockquote>
<p><strong>decorate</strong> : bool</p>
<blockquote>
<div><p>Decorate the window. Default True.</p>
</div></blockquote>
<p><strong>fullscreen</strong> : bool | int</p>
<blockquote>
<div><p>If False, windowed mode is used (default). If True, the default
monitor is used. If int, the given monitor number is used.</p>
</div></blockquote>
<p><strong>config</strong> : dict</p>
<blockquote>
<div><p>A dict with OpenGL configuration options, which is combined
with the default configuration options and used to initialize
the context. See <code class="docutils literal"><span class="pre">canvas.context.config</span></code> for possible
options.</p>
</div></blockquote>
<p><strong>shared</strong> : Canvas | GLContext | None</p>
<blockquote>
<div><p>An existing canvas or context to share OpenGL objects with.</p>
</div></blockquote>
<p><strong>keys</strong> : str | dict | None</p>
<blockquote>
<div><p>Default key mapping to use. If 'interactive', escape and F11 will
close the canvas and toggle full-screen mode, respectively.
If dict, maps keys to functions. If dict values are strings,
they are assumed to be <code class="docutils literal"><span class="pre">Canvas</span></code> methods, otherwise they should
be callable.</p>
</div></blockquote>
<p><strong>parent</strong> : widget-object</p>
<blockquote>
<div><p>The parent widget if this makes sense for the used backend.</p>
</div></blockquote>
<p><strong>dpi</strong> : float | None</p>
<blockquote>
<div><p>Resolution in dots-per-inch to use for the canvas. If dpi is None,
then the value will be determined by querying the global config first,
and then the operating system.</p>
</div></blockquote>
<p><strong>always_on_top</strong> : bool</p>
<blockquote>
<div><p>If True, try to create the window in always-on-top mode.</p>
</div></blockquote>
<p><strong>px_scale</strong> : int &gt; 0</p>
<blockquote>
<div><p>A scale factor to apply between logical and physical pixels in addition
to the actual scale factor determined by the backend. This option
allows the scale factor to be adjusted for testing.</p>
</div></blockquote>
<p><strong>bgcolor</strong> : Color</p>
<blockquote class="last">
<div><p>The background color to use.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="app.html#vispy.app.Canvas" title="vispy.app.Canvas"><code class="xref py py-obj docutils literal"><span class="pre">vispy.app.Canvas</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Receives the following events:</p>
<blockquote>
<div><ul class="simple">
<li>initialize</li>
<li>resize</li>
<li>draw</li>
<li>mouse_press</li>
<li>mouse_release</li>
<li>mouse_double_click</li>
<li>mouse_move</li>
<li>mouse_wheel</li>
<li>key_press</li>
<li>key_release</li>
<li>stylus</li>
<li>touch</li>
<li>close</li>
</ul>
</div></blockquote>
<p>The ordering of the mouse_double_click, mouse_press, and mouse_release
events are not guaranteed to be consistent between backends. Only certain
backends natively support double-clicking (currently Qt and WX); on other
backends, they are detected manually with a fixed time delay.
This can cause problems with accessibility, as increasing the OS detection
time or using a dedicated double-click button will not be respected.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">close</span></code>()</td>
<td>Close the canvas</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">connect</span></code>(fun)</td>
<td>Connect a function to an event</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">create_native</span></code>()</td>
<td>Create the native widget if not already done so.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.SceneCanvas.draw_visual" title="vispy.scene.SceneCanvas.draw_visual"><code class="xref py py-obj docutils literal"><span class="pre">draw_visual</span></code></a>(visual[,&nbsp;event,&nbsp;viewport])</td>
<td>Draw a visual to the canvas or currently active framebuffer.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">measure_fps</span></code>([window,&nbsp;callback])</td>
<td>Measure the current FPS</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.SceneCanvas.on_draw" title="vispy.scene.SceneCanvas.on_draw"><code class="xref py py-obj docutils literal"><span class="pre">on_draw</span></code></a>(event)</td>
<td>Draw handler</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.SceneCanvas.on_resize" title="vispy.scene.SceneCanvas.on_resize"><code class="xref py py-obj docutils literal"><span class="pre">on_resize</span></code></a>(event)</td>
<td>Resize handler</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.SceneCanvas.pop_fbo" title="vispy.scene.SceneCanvas.pop_fbo"><code class="xref py py-obj docutils literal"><span class="pre">pop_fbo</span></code></a>()</td>
<td>Pop an FBO from the stack.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.SceneCanvas.pop_viewport" title="vispy.scene.SceneCanvas.pop_viewport"><code class="xref py py-obj docutils literal"><span class="pre">pop_viewport</span></code></a>()</td>
<td>Pop a viewport from the stack.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.SceneCanvas.push_fbo" title="vispy.scene.SceneCanvas.push_fbo"><code class="xref py py-obj docutils literal"><span class="pre">push_fbo</span></code></a>(fbo,&nbsp;offset,&nbsp;csize)</td>
<td>Push an FBO on the stack, together with the new viewport.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.SceneCanvas.push_viewport" title="vispy.scene.SceneCanvas.push_viewport"><code class="xref py py-obj docutils literal"><span class="pre">push_viewport</span></code></a>(viewport)</td>
<td>Push a viewport on the stack</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.SceneCanvas.render" title="vispy.scene.SceneCanvas.render"><code class="xref py py-obj docutils literal"><span class="pre">render</span></code></a>([region,&nbsp;size])</td>
<td>Render the scene to an offscreen buffer and return the image array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_current</span></code>([event])</td>
<td>Make this the active GL canvas</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">show</span></code>([visible,&nbsp;run])</td>
<td>Show or hide the canvas</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">swap_buffers</span></code>([event])</td>
<td>Swap GL buffers such that the offscreen buffer becomes visible</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>([event])</td>
<td>Inform the backend that the Canvas needs to be redrawn</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="vispy.scene.SceneCanvas.canvas_fb_transform">
<code class="descname">canvas_fb_transform</code><a class="headerlink" href="#vispy.scene.SceneCanvas.canvas_fb_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The transform that maps from the canvas coordinate system to the
current framebuffer coordinate system.</p>
<p>The framebuffer coordinate 
system is used for antialiasing calculations, and is also the 
system used when specifying coordinates for glViewport 
(or gloo.set_viewport). Its origin is in the lower-left corner (as
opposed to the document / canvas coordinate system, which has its
origin in the upper-left corner).</p>
<p>Often the canvas and framebuffer coordinate systems are identical. 
However, some systems with high-resolution 
displays may use framebuffers with higher resolution than the reported
size of the canvas. Likewise, when rendering to an FBO, the resolution
and offset of the framebuffer may not match the canvas.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.SceneCanvas.central_widget">
<code class="descname">central_widget</code><a class="headerlink" href="#vispy.scene.SceneCanvas.central_widget" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default widget that occupies the entire area of the
canvas.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.SceneCanvas.draw_visual">
<code class="descname">draw_visual</code><span class="sig-paren">(</span><em>visual</em>, <em>event=None</em>, <em>viewport=None</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.SceneCanvas.draw_visual" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a visual to the canvas or currently active framebuffer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>visual</strong> : Visual</p>
<blockquote>
<div><p>The visual to draw</p>
</div></blockquote>
<p><strong>event</strong> : None or DrawEvent</p>
<blockquote>
<div><p>Optionally specifies the original canvas draw event that initiated
this draw.</p>
</div></blockquote>
<p><strong>viewport</strong> : tuple | None</p>
<blockquote class="last">
<div><p>Optionally specifies the viewport to use. If None, the entire
physical size is used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.SceneCanvas.fb_ndc_transform">
<code class="descname">fb_ndc_transform</code><a class="headerlink" href="#vispy.scene.SceneCanvas.fb_ndc_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The transform that maps from the framebuffer coordinate system to
normalized device coordinates (which is the obligatory output 
coordinate system for all vertex shaders). This transform accounts for
the current glViewport.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.SceneCanvas.on_draw">
<code class="descname">on_draw</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.SceneCanvas.on_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw handler</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : instance of Event</p>
<blockquote class="last">
<div><p>The draw event.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.SceneCanvas.on_resize">
<code class="descname">on_resize</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.SceneCanvas.on_resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize handler</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : instance of Event</p>
<blockquote class="last">
<div><p>The resize event.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.SceneCanvas.pop_fbo">
<code class="descname">pop_fbo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.SceneCanvas.pop_fbo" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop an FBO from the stack.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.SceneCanvas.pop_viewport">
<code class="descname">pop_viewport</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.SceneCanvas.pop_viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop a viewport from the stack.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.SceneCanvas.push_fbo">
<code class="descname">push_fbo</code><span class="sig-paren">(</span><em>fbo</em>, <em>offset</em>, <em>csize</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.SceneCanvas.push_fbo" title="Permalink to this definition">¶</a></dt>
<dd><p>Push an FBO on the stack, together with the new viewport.
and the transform to the FBO.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fbo</strong> : instance of FrameBuffer</p>
<blockquote>
<div><p>The framebuffer.</p>
</div></blockquote>
<p><strong>offset</strong> : tuple</p>
<blockquote>
<div><p>The offset.</p>
</div></blockquote>
<p><strong>csize</strong> : tuple</p>
<blockquote class="last">
<div><p>The size to use.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.SceneCanvas.push_viewport">
<code class="descname">push_viewport</code><span class="sig-paren">(</span><em>viewport</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.SceneCanvas.push_viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>Push a viewport on the stack</p>
<p>It is the responsibility of the caller to ensure the given values are
int. The viewport's origin is defined relative to the current
viewport.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>viewport</strong> : tuple</p>
<blockquote class="last">
<div><p>The viewport as (x, y, w, h).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.SceneCanvas.render">
<code class="descname">render</code><span class="sig-paren">(</span><em>region=None</em>, <em>size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.SceneCanvas.render" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the scene to an offscreen buffer and return the image array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>region</strong> : tuple | None</p>
<blockquote>
<div><p>Specifies the region of the canvas to render. Format is 
(x, y, w, h). By default, the entire canvas is rendered.</p>
</div></blockquote>
<p><strong>size</strong> : tuple | None</p>
<blockquote>
<div><p>Specifies the size of the image array to return. If no size is 
given, then the size of the <em>region</em> is used. This argument allows
the scene to be rendered at resolutions different from the native
canvas resolution.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote class="last">
<div><p>Numpy array of type ubyte and shape (h, w, 4). Index [0, 0] is the 
upper-left corner of the rendered region.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.SceneCanvas.render_transform">
<code class="descname">render_transform</code><a class="headerlink" href="#vispy.scene.SceneCanvas.render_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The transform that maps from the Canvas pixel coordinate system 
&lt;(0, 0) at top-left, (w, h) at bottom-right&gt; to normalized device 
coordinates within the current glViewport and FBO.</p>
<p>Most visuals should use this transform when drawing.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.SceneCanvas.scene">
<code class="descname">scene</code><a class="headerlink" href="#vispy.scene.SceneCanvas.scene" title="Permalink to this definition">¶</a></dt>
<dd><p>The SubScene object that represents the root node of the
scene graph to be displayed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vispy.scene.Node">
<em class="property">class </em><code class="descclassname">vispy.scene.</code><code class="descname">Node</code><span class="sig-paren">(</span><em>parent=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Base class representing an object in a scene.</p>
<p>A group of nodes connected through parent-child relationships define a 
scenegraph. Nodes may have any number of children or parents, although 
it is uncommon to have more than one parent.</p>
<p>Each Node defines a <code class="docutils literal"><span class="pre">transform</span></code> property, which describes the position,
orientation, scale, etc. of the Node relative to its parent. The Node's
children inherit this property, and then further apply their own
transformations on top of that.</p>
<p>With the <code class="docutils literal"><span class="pre">transform</span></code> property, each Node implicitly defines a &quot;local&quot; 
coordinate system, and the Nodes and edges in the scenegraph can be though
of as coordinate systems connected by transformation functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent of the Node.</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote class="last">
<div><p>The name used to identify the node.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.Node.add_parent" title="vispy.scene.Node.add_parent"><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code></a>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.Node.common_parent" title="vispy.scene.Node.common_parent"><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code></a>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.Node.describe_tree" title="vispy.scene.Node.describe_tree"><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code></a>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.Node.node_path" title="vispy.scene.Node.node_path"><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code></a>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.Node.node_path_to_child" title="vispy.scene.Node.node_path_to_child"><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code></a>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.Node.node_path_transforms" title="vispy.scene.Node.node_path_transforms"><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code></a>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.Node.node_transform" title="vispy.scene.Node.node_transform"><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code></a>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.Node.remove_parent" title="vispy.scene.Node.remove_parent"><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code></a>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.Node.set_transform" title="vispy.scene.Node.set_transform"><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code></a>(<a href="#id1"><span class="problematic" id="id2">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.Node.update" title="vispy.scene.Node.update"><code class="xref py py-obj docutils literal"><span class="pre">update</span></code></a>()</td>
<td>Emit an event to inform listeners that properties of this Node or its children have changed.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="vispy.scene.Node.add_parent">
<code class="descname">add_parent</code><span class="sig-paren">(</span><em>parent</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.Node.add_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a parent</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parent</strong> : instance of Node</p>
<blockquote class="last">
<div><p>The parent.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.Node.children">
<code class="descname">children</code><a class="headerlink" href="#vispy.scene.Node.children" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of the list of children of this node. Do not add
items to this list, but use <code class="docutils literal"><span class="pre">x.parent</span> <span class="pre">=</span> <span class="pre">y</span></code> instead.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.Node.common_parent">
<code class="descname">common_parent</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.Node.common_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the common parent of two entities</p>
<p>If the entities have no common parent, return None.
Does not search past multi-parent branches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : instance of Node</p>
<blockquote>
<div><p>The other node.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>parent</strong> : instance of Node | None</p>
<blockquote class="last">
<div><p>The parent.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.Node.describe_tree">
<code class="descname">describe_tree</code><span class="sig-paren">(</span><em>with_transform=False</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.Node.describe_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Create tree diagram of children</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>with_transform</strong> : bool</p>
<blockquote>
<div><p>If true, add information about node transform types.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tree</strong> : str</p>
<blockquote class="last">
<div><p>The tree diagram.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.Node.document">
<code class="descname">document</code><a class="headerlink" href="#vispy.scene.Node.document" title="Permalink to this definition">¶</a></dt>
<dd><p>The document is an optional property that is an node representing
the coordinate system from which this node should make physical 
measurements such as px, mm, pt, in, etc. This coordinate system 
should be used when determining line widths, font sizes, and any
other lengths specified in physical units.</p>
<p>The default is None; in this case, a default document is used during
drawing (usually this is supplied by the SceneCanvas).</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.Node.node_path">
<code class="descname">node_path</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.Node.node_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return two lists describing the path from this node to another</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : instance of Node</p>
<blockquote>
<div><p>The other node.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p1</strong> : list</p>
<blockquote>
<div><p>First path (see below).</p>
</div></blockquote>
<p><strong>p2</strong> : list</p>
<blockquote class="last">
<div><p>Second path (see below).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The first list starts with this node and ends with the common parent
between the endpoint nodes. The second list contains the remainder of
the path from the common parent to the specified ending node.</p>
<p>For example, consider the following scenegraph:</p>
<div class="highlight-python"><div class="highlight"><pre>A --- B --- C --- D
                           --- E --- F
</pre></div>
</div>
<p>Calling <cite>D.node_path(F)</cite> will return:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">([</span><span class="n">D</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">E</span><span class="p">,</span> <span class="n">F</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that there must be a _single_ path in the scenegraph that connects
the two entities; otherwise an exception will be raised.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.Node.node_path_to_child">
<code class="descname">node_path_to_child</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.Node.node_path_to_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list describing the path from this node to a child node</p>
<p>This method assumes that the given node is a child node. Multiple
parenting is allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : instance of Node</p>
<blockquote>
<div><p>The child node.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>path</strong> : list | None</p>
<blockquote class="last">
<div><p>The path.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.Node.node_path_transforms">
<code class="descname">node_path_transforms</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.Node.node_path_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of transforms along the path to another node.</p>
<p>The transforms are listed in reverse order, such that the last 
transform should be applied first when mapping from this node to 
the other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : instance of Node</p>
<blockquote>
<div><p>The other node.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>transform</strong> : instance of Transform</p>
<blockquote class="last">
<div><p>The transform.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.Node.node_transform">
<code class="descname">node_transform</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.Node.node_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transform that maps from the coordinate system of
<em>self</em> to the local coordinate system of <em>node</em>.</p>
<p>Note that there must be a _single_ path in the scenegraph that connects
the two entities; otherwise an exception will be raised.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : instance of Node</p>
<blockquote>
<div><p>The other node.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>transform</strong> : instance of ChainTransform</p>
<blockquote class="last">
<div><p>The transform.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.Node.parent">
<code class="descname">parent</code><a class="headerlink" href="#vispy.scene.Node.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Get/set the parent. If the node has multiple parents while
using this property as a getter, an error is raised.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.Node.parents">
<code class="descname">parents</code><a class="headerlink" href="#vispy.scene.Node.parents" title="Permalink to this definition">¶</a></dt>
<dd><p>Get/set a tuple of parents.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.Node.remove_parent">
<code class="descname">remove_parent</code><span class="sig-paren">(</span><em>parent</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.Node.remove_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a parent</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parent</strong> : instance of Node</p>
<blockquote class="last">
<div><p>The parent.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.Node.set_transform">
<code class="descname">set_transform</code><span class="sig-paren">(</span><em>type_</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.Node.set_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new transform of <em>type</em> and assign it to this node.</p>
<p>All extra arguments are used in the construction of the transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>type_</strong> : str</p>
<blockquote>
<div><p>The transform type.</p>
</div></blockquote>
<p><strong>*args</strong> : tuple</p>
<blockquote>
<div><p>Arguments.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Keywoard arguments.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.Node.transform">
<code class="descname">transform</code><a class="headerlink" href="#vispy.scene.Node.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The transform that maps the local coordinate frame to the
coordinate frame of the parent.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.Node.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.Node.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Emit an event to inform listeners that properties of this Node or its
children have changed.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.Node.visible">
<code class="descname">visible</code><a class="headerlink" href="#vispy.scene.Node.visible" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether this node should be drawn or not. Only applicable to
nodes that can be drawn.</p>
</dd></dl>

</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-vispy.scene.cameras">
<span id="vispy-scene-cameras"></span><h2>vispy.scene.cameras<a class="headerlink" href="#module-vispy.scene.cameras" title="Permalink to this headline">¶</a></h2>
<p>Cameras are responsible for determining which part of a scene is displayed
in a viewbox and for handling user input to change the view.</p>
<p>Several Camera subclasses are available to customize the projection of the 
scene such as 3D perspective and orthographic projections, 2D 
scale/translation, and other specialty cameras. A variety of user interaction
styles are available for each camera including arcball, turntable, 
first-person, and pan/zoom interactions.</p>
<p>Internally, Cameras work by setting the transform of a SubScene object such 
that a certain part of the scene is mapped to the bounding rectangle of the 
ViewBox.</p>
</div>
<hr class="docutils" />
<div class="section" id="module-vispy.scene.canvas">
<span id="vispy-scene-canvas"></span><h2>vispy.scene.canvas<a class="headerlink" href="#module-vispy.scene.canvas" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="vispy.scene.canvas.SceneCanvas">
<em class="property">class </em><code class="descclassname">vispy.scene.canvas.</code><code class="descname">SceneCanvas</code><span class="sig-paren">(</span><em>title='Vispy canvas'</em>, <em>size=(800</em>, <em>600)</em>, <em>position=None</em>, <em>show=False</em>, <em>autoswap=True</em>, <em>app=None</em>, <em>create_native=True</em>, <em>vsync=False</em>, <em>resizable=True</em>, <em>decorate=True</em>, <em>fullscreen=False</em>, <em>config=None</em>, <em>shared=None</em>, <em>keys=None</em>, <em>parent=None</em>, <em>dpi=None</em>, <em>always_on_top=False</em>, <em>px_scale=1</em>, <em>bgcolor='black'</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.app.canvas.Canvas</span></code></p>
<p>A Canvas that automatically draws the contents of a scene</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>title</strong> : str</p>
<blockquote>
<div><p>The widget title</p>
</div></blockquote>
<p><strong>size</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the window.</p>
</div></blockquote>
<p><strong>position</strong> : (x, y)</p>
<blockquote>
<div><p>The position of the window in screen coordinates.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Whether to show the widget immediately. Default False.</p>
</div></blockquote>
<p><strong>autoswap</strong> : bool</p>
<blockquote>
<div><p>Whether to swap the buffers automatically after a draw event.
Default True. If True, the <code class="docutils literal"><span class="pre">swap_buffers</span></code> Canvas method will
be called last (by default) by the <code class="docutils literal"><span class="pre">canvas.draw</span></code> event handler.</p>
</div></blockquote>
<p><strong>app</strong> : Application | str</p>
<blockquote>
<div><p>Give vispy Application instance to use as a backend.
(vispy.app is used by default.) If str, then an application
using the chosen backend (e.g., 'pyglet') will be created.
Note the canvas application can be accessed at <code class="docutils literal"><span class="pre">canvas.app</span></code>.</p>
</div></blockquote>
<p><strong>create_native</strong> : bool</p>
<blockquote>
<div><p>Whether to create the widget immediately. Default True.</p>
</div></blockquote>
<p><strong>vsync</strong> : bool</p>
<blockquote>
<div><p>Enable vertical synchronization.</p>
</div></blockquote>
<p><strong>resizable</strong> : bool</p>
<blockquote>
<div><p>Allow the window to be resized.</p>
</div></blockquote>
<p><strong>decorate</strong> : bool</p>
<blockquote>
<div><p>Decorate the window. Default True.</p>
</div></blockquote>
<p><strong>fullscreen</strong> : bool | int</p>
<blockquote>
<div><p>If False, windowed mode is used (default). If True, the default
monitor is used. If int, the given monitor number is used.</p>
</div></blockquote>
<p><strong>config</strong> : dict</p>
<blockquote>
<div><p>A dict with OpenGL configuration options, which is combined
with the default configuration options and used to initialize
the context. See <code class="docutils literal"><span class="pre">canvas.context.config</span></code> for possible
options.</p>
</div></blockquote>
<p><strong>shared</strong> : Canvas | GLContext | None</p>
<blockquote>
<div><p>An existing canvas or context to share OpenGL objects with.</p>
</div></blockquote>
<p><strong>keys</strong> : str | dict | None</p>
<blockquote>
<div><p>Default key mapping to use. If 'interactive', escape and F11 will
close the canvas and toggle full-screen mode, respectively.
If dict, maps keys to functions. If dict values are strings,
they are assumed to be <code class="docutils literal"><span class="pre">Canvas</span></code> methods, otherwise they should
be callable.</p>
</div></blockquote>
<p><strong>parent</strong> : widget-object</p>
<blockquote>
<div><p>The parent widget if this makes sense for the used backend.</p>
</div></blockquote>
<p><strong>dpi</strong> : float | None</p>
<blockquote>
<div><p>Resolution in dots-per-inch to use for the canvas. If dpi is None,
then the value will be determined by querying the global config first,
and then the operating system.</p>
</div></blockquote>
<p><strong>always_on_top</strong> : bool</p>
<blockquote>
<div><p>If True, try to create the window in always-on-top mode.</p>
</div></blockquote>
<p><strong>px_scale</strong> : int &gt; 0</p>
<blockquote>
<div><p>A scale factor to apply between logical and physical pixels in addition
to the actual scale factor determined by the backend. This option
allows the scale factor to be adjusted for testing.</p>
</div></blockquote>
<p><strong>bgcolor</strong> : Color</p>
<blockquote class="last">
<div><p>The background color to use.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="app.html#vispy.app.Canvas" title="vispy.app.Canvas"><code class="xref py py-obj docutils literal"><span class="pre">vispy.app.Canvas</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Receives the following events:</p>
<blockquote>
<div><ul class="simple">
<li>initialize</li>
<li>resize</li>
<li>draw</li>
<li>mouse_press</li>
<li>mouse_release</li>
<li>mouse_double_click</li>
<li>mouse_move</li>
<li>mouse_wheel</li>
<li>key_press</li>
<li>key_release</li>
<li>stylus</li>
<li>touch</li>
<li>close</li>
</ul>
</div></blockquote>
<p>The ordering of the mouse_double_click, mouse_press, and mouse_release
events are not guaranteed to be consistent between backends. Only certain
backends natively support double-clicking (currently Qt and WX); on other
backends, they are detected manually with a fixed time delay.
This can cause problems with accessibility, as increasing the OS detection
time or using a dedicated double-click button will not be respected.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">close</span></code>()</td>
<td>Close the canvas</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">connect</span></code>(fun)</td>
<td>Connect a function to an event</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">create_native</span></code>()</td>
<td>Create the native widget if not already done so.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.canvas.SceneCanvas.draw_visual" title="vispy.scene.canvas.SceneCanvas.draw_visual"><code class="xref py py-obj docutils literal"><span class="pre">draw_visual</span></code></a>(visual[,&nbsp;event,&nbsp;viewport])</td>
<td>Draw a visual to the canvas or currently active framebuffer.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">measure_fps</span></code>([window,&nbsp;callback])</td>
<td>Measure the current FPS</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.canvas.SceneCanvas.on_draw" title="vispy.scene.canvas.SceneCanvas.on_draw"><code class="xref py py-obj docutils literal"><span class="pre">on_draw</span></code></a>(event)</td>
<td>Draw handler</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.canvas.SceneCanvas.on_resize" title="vispy.scene.canvas.SceneCanvas.on_resize"><code class="xref py py-obj docutils literal"><span class="pre">on_resize</span></code></a>(event)</td>
<td>Resize handler</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.canvas.SceneCanvas.pop_fbo" title="vispy.scene.canvas.SceneCanvas.pop_fbo"><code class="xref py py-obj docutils literal"><span class="pre">pop_fbo</span></code></a>()</td>
<td>Pop an FBO from the stack.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.canvas.SceneCanvas.pop_viewport" title="vispy.scene.canvas.SceneCanvas.pop_viewport"><code class="xref py py-obj docutils literal"><span class="pre">pop_viewport</span></code></a>()</td>
<td>Pop a viewport from the stack.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.canvas.SceneCanvas.push_fbo" title="vispy.scene.canvas.SceneCanvas.push_fbo"><code class="xref py py-obj docutils literal"><span class="pre">push_fbo</span></code></a>(fbo,&nbsp;offset,&nbsp;csize)</td>
<td>Push an FBO on the stack, together with the new viewport.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.canvas.SceneCanvas.push_viewport" title="vispy.scene.canvas.SceneCanvas.push_viewport"><code class="xref py py-obj docutils literal"><span class="pre">push_viewport</span></code></a>(viewport)</td>
<td>Push a viewport on the stack</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.canvas.SceneCanvas.render" title="vispy.scene.canvas.SceneCanvas.render"><code class="xref py py-obj docutils literal"><span class="pre">render</span></code></a>([region,&nbsp;size])</td>
<td>Render the scene to an offscreen buffer and return the image array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_current</span></code>([event])</td>
<td>Make this the active GL canvas</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">show</span></code>([visible,&nbsp;run])</td>
<td>Show or hide the canvas</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">swap_buffers</span></code>([event])</td>
<td>Swap GL buffers such that the offscreen buffer becomes visible</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>([event])</td>
<td>Inform the backend that the Canvas needs to be redrawn</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="vispy.scene.canvas.SceneCanvas.canvas_fb_transform">
<code class="descname">canvas_fb_transform</code><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.canvas_fb_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The transform that maps from the canvas coordinate system to the
current framebuffer coordinate system.</p>
<p>The framebuffer coordinate 
system is used for antialiasing calculations, and is also the 
system used when specifying coordinates for glViewport 
(or gloo.set_viewport). Its origin is in the lower-left corner (as
opposed to the document / canvas coordinate system, which has its
origin in the upper-left corner).</p>
<p>Often the canvas and framebuffer coordinate systems are identical. 
However, some systems with high-resolution 
displays may use framebuffers with higher resolution than the reported
size of the canvas. Likewise, when rendering to an FBO, the resolution
and offset of the framebuffer may not match the canvas.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.canvas.SceneCanvas.central_widget">
<code class="descname">central_widget</code><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.central_widget" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default widget that occupies the entire area of the
canvas.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.canvas.SceneCanvas.draw_visual">
<code class="descname">draw_visual</code><span class="sig-paren">(</span><em>visual</em>, <em>event=None</em>, <em>viewport=None</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.draw_visual" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a visual to the canvas or currently active framebuffer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>visual</strong> : Visual</p>
<blockquote>
<div><p>The visual to draw</p>
</div></blockquote>
<p><strong>event</strong> : None or DrawEvent</p>
<blockquote>
<div><p>Optionally specifies the original canvas draw event that initiated
this draw.</p>
</div></blockquote>
<p><strong>viewport</strong> : tuple | None</p>
<blockquote class="last">
<div><p>Optionally specifies the viewport to use. If None, the entire
physical size is used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.canvas.SceneCanvas.fb_ndc_transform">
<code class="descname">fb_ndc_transform</code><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.fb_ndc_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The transform that maps from the framebuffer coordinate system to
normalized device coordinates (which is the obligatory output 
coordinate system for all vertex shaders). This transform accounts for
the current glViewport.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.canvas.SceneCanvas.on_draw">
<code class="descname">on_draw</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.on_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw handler</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : instance of Event</p>
<blockquote class="last">
<div><p>The draw event.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.canvas.SceneCanvas.on_resize">
<code class="descname">on_resize</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.on_resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize handler</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : instance of Event</p>
<blockquote class="last">
<div><p>The resize event.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.canvas.SceneCanvas.pop_fbo">
<code class="descname">pop_fbo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.pop_fbo" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop an FBO from the stack.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.canvas.SceneCanvas.pop_viewport">
<code class="descname">pop_viewport</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.pop_viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop a viewport from the stack.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.canvas.SceneCanvas.push_fbo">
<code class="descname">push_fbo</code><span class="sig-paren">(</span><em>fbo</em>, <em>offset</em>, <em>csize</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.push_fbo" title="Permalink to this definition">¶</a></dt>
<dd><p>Push an FBO on the stack, together with the new viewport.
and the transform to the FBO.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fbo</strong> : instance of FrameBuffer</p>
<blockquote>
<div><p>The framebuffer.</p>
</div></blockquote>
<p><strong>offset</strong> : tuple</p>
<blockquote>
<div><p>The offset.</p>
</div></blockquote>
<p><strong>csize</strong> : tuple</p>
<blockquote class="last">
<div><p>The size to use.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.canvas.SceneCanvas.push_viewport">
<code class="descname">push_viewport</code><span class="sig-paren">(</span><em>viewport</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.push_viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>Push a viewport on the stack</p>
<p>It is the responsibility of the caller to ensure the given values are
int. The viewport's origin is defined relative to the current
viewport.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>viewport</strong> : tuple</p>
<blockquote class="last">
<div><p>The viewport as (x, y, w, h).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.canvas.SceneCanvas.render">
<code class="descname">render</code><span class="sig-paren">(</span><em>region=None</em>, <em>size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.render" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the scene to an offscreen buffer and return the image array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>region</strong> : tuple | None</p>
<blockquote>
<div><p>Specifies the region of the canvas to render. Format is 
(x, y, w, h). By default, the entire canvas is rendered.</p>
</div></blockquote>
<p><strong>size</strong> : tuple | None</p>
<blockquote>
<div><p>Specifies the size of the image array to return. If no size is 
given, then the size of the <em>region</em> is used. This argument allows
the scene to be rendered at resolutions different from the native
canvas resolution.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote class="last">
<div><p>Numpy array of type ubyte and shape (h, w, 4). Index [0, 0] is the 
upper-left corner of the rendered region.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.canvas.SceneCanvas.render_transform">
<code class="descname">render_transform</code><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.render_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The transform that maps from the Canvas pixel coordinate system 
&lt;(0, 0) at top-left, (w, h) at bottom-right&gt; to normalized device 
coordinates within the current glViewport and FBO.</p>
<p>Most visuals should use this transform when drawing.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.canvas.SceneCanvas.scene">
<code class="descname">scene</code><a class="headerlink" href="#vispy.scene.canvas.SceneCanvas.scene" title="Permalink to this definition">¶</a></dt>
<dd><p>The SubScene object that represents the root node of the
scene graph to be displayed.</p>
</dd></dl>

</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-vispy.scene.node">
<span id="vispy-scene-node"></span><h2>vispy.scene.node<a class="headerlink" href="#module-vispy.scene.node" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="vispy.scene.node.Node">
<em class="property">class </em><code class="descclassname">vispy.scene.node.</code><code class="descname">Node</code><span class="sig-paren">(</span><em>parent=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.node.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Base class representing an object in a scene.</p>
<p>A group of nodes connected through parent-child relationships define a 
scenegraph. Nodes may have any number of children or parents, although 
it is uncommon to have more than one parent.</p>
<p>Each Node defines a <code class="docutils literal"><span class="pre">transform</span></code> property, which describes the position,
orientation, scale, etc. of the Node relative to its parent. The Node's
children inherit this property, and then further apply their own
transformations on top of that.</p>
<p>With the <code class="docutils literal"><span class="pre">transform</span></code> property, each Node implicitly defines a &quot;local&quot; 
coordinate system, and the Nodes and edges in the scenegraph can be though
of as coordinate systems connected by transformation functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent of the Node.</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote class="last">
<div><p>The name used to identify the node.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.node.Node.add_parent" title="vispy.scene.node.Node.add_parent"><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code></a>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.node.Node.common_parent" title="vispy.scene.node.Node.common_parent"><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code></a>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.node.Node.describe_tree" title="vispy.scene.node.Node.describe_tree"><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code></a>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.node.Node.node_path" title="vispy.scene.node.Node.node_path"><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code></a>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.node.Node.node_path_to_child" title="vispy.scene.node.Node.node_path_to_child"><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code></a>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.node.Node.node_path_transforms" title="vispy.scene.node.Node.node_path_transforms"><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code></a>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.node.Node.node_transform" title="vispy.scene.node.Node.node_transform"><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code></a>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.node.Node.remove_parent" title="vispy.scene.node.Node.remove_parent"><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code></a>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.node.Node.set_transform" title="vispy.scene.node.Node.set_transform"><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code></a>(<a href="#id3"><span class="problematic" id="id4">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.node.Node.update" title="vispy.scene.node.Node.update"><code class="xref py py-obj docutils literal"><span class="pre">update</span></code></a>()</td>
<td>Emit an event to inform listeners that properties of this Node or its children have changed.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="vispy.scene.node.Node.add_parent">
<code class="descname">add_parent</code><span class="sig-paren">(</span><em>parent</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.node.Node.add_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a parent</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parent</strong> : instance of Node</p>
<blockquote class="last">
<div><p>The parent.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.node.Node.children">
<code class="descname">children</code><a class="headerlink" href="#vispy.scene.node.Node.children" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of the list of children of this node. Do not add
items to this list, but use <code class="docutils literal"><span class="pre">x.parent</span> <span class="pre">=</span> <span class="pre">y</span></code> instead.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.node.Node.common_parent">
<code class="descname">common_parent</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.node.Node.common_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the common parent of two entities</p>
<p>If the entities have no common parent, return None.
Does not search past multi-parent branches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : instance of Node</p>
<blockquote>
<div><p>The other node.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>parent</strong> : instance of Node | None</p>
<blockquote class="last">
<div><p>The parent.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.node.Node.describe_tree">
<code class="descname">describe_tree</code><span class="sig-paren">(</span><em>with_transform=False</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.node.Node.describe_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Create tree diagram of children</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>with_transform</strong> : bool</p>
<blockquote>
<div><p>If true, add information about node transform types.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tree</strong> : str</p>
<blockquote class="last">
<div><p>The tree diagram.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.node.Node.document">
<code class="descname">document</code><a class="headerlink" href="#vispy.scene.node.Node.document" title="Permalink to this definition">¶</a></dt>
<dd><p>The document is an optional property that is an node representing
the coordinate system from which this node should make physical 
measurements such as px, mm, pt, in, etc. This coordinate system 
should be used when determining line widths, font sizes, and any
other lengths specified in physical units.</p>
<p>The default is None; in this case, a default document is used during
drawing (usually this is supplied by the SceneCanvas).</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.node.Node.node_path">
<code class="descname">node_path</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.node.Node.node_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return two lists describing the path from this node to another</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : instance of Node</p>
<blockquote>
<div><p>The other node.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p1</strong> : list</p>
<blockquote>
<div><p>First path (see below).</p>
</div></blockquote>
<p><strong>p2</strong> : list</p>
<blockquote class="last">
<div><p>Second path (see below).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The first list starts with this node and ends with the common parent
between the endpoint nodes. The second list contains the remainder of
the path from the common parent to the specified ending node.</p>
<p>For example, consider the following scenegraph:</p>
<div class="highlight-python"><div class="highlight"><pre>A --- B --- C --- D
                           --- E --- F
</pre></div>
</div>
<p>Calling <cite>D.node_path(F)</cite> will return:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">([</span><span class="n">D</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">E</span><span class="p">,</span> <span class="n">F</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that there must be a _single_ path in the scenegraph that connects
the two entities; otherwise an exception will be raised.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.node.Node.node_path_to_child">
<code class="descname">node_path_to_child</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.node.Node.node_path_to_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list describing the path from this node to a child node</p>
<p>This method assumes that the given node is a child node. Multiple
parenting is allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : instance of Node</p>
<blockquote>
<div><p>The child node.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>path</strong> : list | None</p>
<blockquote class="last">
<div><p>The path.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.node.Node.node_path_transforms">
<code class="descname">node_path_transforms</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.node.Node.node_path_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of transforms along the path to another node.</p>
<p>The transforms are listed in reverse order, such that the last 
transform should be applied first when mapping from this node to 
the other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : instance of Node</p>
<blockquote>
<div><p>The other node.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>transform</strong> : instance of Transform</p>
<blockquote class="last">
<div><p>The transform.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.node.Node.node_transform">
<code class="descname">node_transform</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.node.Node.node_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transform that maps from the coordinate system of
<em>self</em> to the local coordinate system of <em>node</em>.</p>
<p>Note that there must be a _single_ path in the scenegraph that connects
the two entities; otherwise an exception will be raised.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : instance of Node</p>
<blockquote>
<div><p>The other node.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>transform</strong> : instance of ChainTransform</p>
<blockquote class="last">
<div><p>The transform.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.node.Node.parent">
<code class="descname">parent</code><a class="headerlink" href="#vispy.scene.node.Node.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Get/set the parent. If the node has multiple parents while
using this property as a getter, an error is raised.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.node.Node.parents">
<code class="descname">parents</code><a class="headerlink" href="#vispy.scene.node.Node.parents" title="Permalink to this definition">¶</a></dt>
<dd><p>Get/set a tuple of parents.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.node.Node.remove_parent">
<code class="descname">remove_parent</code><span class="sig-paren">(</span><em>parent</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.node.Node.remove_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a parent</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parent</strong> : instance of Node</p>
<blockquote class="last">
<div><p>The parent.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.node.Node.set_transform">
<code class="descname">set_transform</code><span class="sig-paren">(</span><em>type_</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.node.Node.set_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new transform of <em>type</em> and assign it to this node.</p>
<p>All extra arguments are used in the construction of the transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>type_</strong> : str</p>
<blockquote>
<div><p>The transform type.</p>
</div></blockquote>
<p><strong>*args</strong> : tuple</p>
<blockquote>
<div><p>Arguments.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Keywoard arguments.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.node.Node.transform">
<code class="descname">transform</code><a class="headerlink" href="#vispy.scene.node.Node.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The transform that maps the local coordinate frame to the
coordinate frame of the parent.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.node.Node.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.node.Node.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Emit an event to inform listeners that properties of this Node or its
children have changed.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.node.Node.visible">
<code class="descname">visible</code><a class="headerlink" href="#vispy.scene.node.Node.visible" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether this node should be drawn or not. Only applicable to
nodes that can be drawn.</p>
</dd></dl>

</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-vispy.scene.events">
<span id="vispy-scene-events"></span><h2>vispy.scene.events<a class="headerlink" href="#module-vispy.scene.events" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="vispy.scene.events.SceneEvent">
<em class="property">class </em><code class="descclassname">vispy.scene.events.</code><code class="descname">SceneEvent</code><span class="sig-paren">(</span><em>type</em>, <em>canvas</em>, <em>transform_cache=None</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.events.SceneEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="util.html#vispy.util.event.Event" title="vispy.util.event.Event"><code class="xref py py-class docutils literal"><span class="pre">vispy.util.event.Event</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.transforms.transform_system.TransformSystem</span></code></p>
<p>SceneEvent is an Event that tracks its path through a scenegraph,
beginning at a Canvas. It exposes information useful during drawing
and user interaction.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">auto_configure</span></code>()</td>
<td>Automatically configure the TransformSystem:</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.events.SceneEvent.get_full_transform" title="vispy.scene.events.SceneEvent.get_full_transform"><code class="xref py py-obj docutils literal"><span class="pre">get_full_transform</span></code></a>()</td>
<td>Return the transform that maps from the current node to normalized device coordinates within the current glViewport and FBO.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.events.SceneEvent.node_transform" title="vispy.scene.events.SceneEvent.node_transform"><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code></a>([map_to,&nbsp;map_from])</td>
<td>Return the transform from <em>map_from</em> to <em>map_to</em>, using the current node stack to resolve parent ambiguities if needed.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">pop_document</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.events.SceneEvent.pop_fbo" title="vispy.scene.events.SceneEvent.pop_fbo"><code class="xref py py-obj docutils literal"><span class="pre">pop_fbo</span></code></a>()</td>
<td>Pop an FBO from the stack.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.events.SceneEvent.pop_node" title="vispy.scene.events.SceneEvent.pop_node"><code class="xref py py-obj docutils literal"><span class="pre">pop_node</span></code></a>()</td>
<td>Pop an node from the stack.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">pop_viewbox</span></code>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.events.SceneEvent.pop_viewport" title="vispy.scene.events.SceneEvent.pop_viewport"><code class="xref py py-obj docutils literal"><span class="pre">pop_viewport</span></code></a>()</td>
<td>Pop a viewport from the stack.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">push_document</span></code>(doc)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.events.SceneEvent.push_fbo" title="vispy.scene.events.SceneEvent.push_fbo"><code class="xref py py-obj docutils literal"><span class="pre">push_fbo</span></code></a>(viewport,&nbsp;fbo,&nbsp;transform)</td>
<td>Push an FBO on the stack, together with the new viewport.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.events.SceneEvent.push_node" title="vispy.scene.events.SceneEvent.push_node"><code class="xref py py-obj docutils literal"><span class="pre">push_node</span></code></a>(node)</td>
<td>Push an node on the stack.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">push_viewbox</span></code>(viewbox)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.events.SceneEvent.push_viewport" title="vispy.scene.events.SceneEvent.push_viewport"><code class="xref py py-obj docutils literal"><span class="pre">push_viewport</span></code></a>(viewport)</td>
<td>Push a viewport (x, y, w, h) on the stack.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.canvas">
<code class="descname">canvas</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.canvas" title="Permalink to this definition">¶</a></dt>
<dd><p>The Canvas that originated this SceneEvent</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.canvas_cs">
<code class="descname">canvas_cs</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.canvas_cs" title="Permalink to this definition">¶</a></dt>
<dd><p>The node for the current canvas coordinate system. This cs
represents the logical pixels of the canvas being drawn, with the
origin in upper-left, and the canvas (width, height) in the bottom
right. This coordinate system is most often used for handling mouse
input.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.document_cs">
<code class="descname">document_cs</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.document_cs" title="Permalink to this definition">¶</a></dt>
<dd><p>The node for the current document coordinate system. The
coordinate system of this Node is used for making physical
measurements--px, mm, in, etc.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.document_to_framebuffer">
<code class="descname">document_to_framebuffer</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.document_to_framebuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform mapping from document coordinate frame to the framebuffer
(physical pixel) coordinate frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.framebuffer_cs">
<code class="descname">framebuffer_cs</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.framebuffer_cs" title="Permalink to this definition">¶</a></dt>
<dd><p>The node for the current framebuffer coordinate system. This
coordinate system corresponds to the physical pixels being rendered
to, with the origin in lower-right, and the framebufer (width, height)
in upper-left. It is used mainly for making antialiasing measurements.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.framebuffer_to_render">
<code class="descname">framebuffer_to_render</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.framebuffer_to_render" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform mapping from pixel coordinate frame to rendering
coordinate frame.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.events.SceneEvent.get_full_transform">
<code class="descname">get_full_transform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.events.SceneEvent.get_full_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transform that maps from the current node to
normalized device coordinates within the current glViewport and
FBO.</p>
<p>This transform consists of the full_transform prepended by a
correction for the current glViewport and/or FBO.</p>
<p>Most entities will use this transform when drawing.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.handled_children">
<code class="descname">handled_children</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.handled_children" title="Permalink to this definition">¶</a></dt>
<dd><p>List of children of the current node that have already been
handled.</p>
<p>Nodes that manually process their children (as opposed to allowing
drawing / mouse systems to handle them automatically) may append nodes
to this list to prevent systems from handling them.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.node_cs">
<code class="descname">node_cs</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.node_cs" title="Permalink to this definition">¶</a></dt>
<dd><p>The node at the top of the node stack.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.events.SceneEvent.node_transform">
<code class="descname">node_transform</code><span class="sig-paren">(</span><em>map_to=None</em>, <em>map_from=None</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.events.SceneEvent.node_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transform from <em>map_from</em> to <em>map_to</em>, using the
current node stack to resolve parent ambiguities if needed.</p>
<p>By default, <em>map_to</em> is the normalized device coordinate system,
and <em>map_from</em> is the current top node on the stack.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.path">
<code class="descname">path</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.path" title="Permalink to this definition">¶</a></dt>
<dd><p>The path of Entities leading from the root SubScene to the
current recipient of this Event.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.events.SceneEvent.pop_fbo">
<code class="descname">pop_fbo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.events.SceneEvent.pop_fbo" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop an FBO from the stack.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.events.SceneEvent.pop_node">
<code class="descname">pop_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.events.SceneEvent.pop_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop an node from the stack.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.events.SceneEvent.pop_viewport">
<code class="descname">pop_viewport</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.events.SceneEvent.pop_viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop a viewport from the stack.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.events.SceneEvent.push_fbo">
<code class="descname">push_fbo</code><span class="sig-paren">(</span><em>viewport</em>, <em>fbo</em>, <em>transform</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.events.SceneEvent.push_fbo" title="Permalink to this definition">¶</a></dt>
<dd><p>Push an FBO on the stack, together with the new viewport.
and the transform to the FBO.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.events.SceneEvent.push_node">
<code class="descname">push_node</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.events.SceneEvent.push_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Push an node on the stack.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.events.SceneEvent.push_viewport">
<code class="descname">push_viewport</code><span class="sig-paren">(</span><em>viewport</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.events.SceneEvent.push_viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>Push a viewport (x, y, w, h) on the stack. It is the
responsibility of the caller to ensure the given values are
int. The viewport's origin is defined relative to the current
viewport.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.render_cs">
<code class="descname">render_cs</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.render_cs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return node for the normalized device coordinate system. This
coordinate system is the obligatory output of GLSL vertex shaders,
with (-1, -1) in bottom-left, and (1, 1) in top-right. This coordinate
system is frequently used for rendering visuals because all vertices
must ultimately be mapped here.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.scene_transform">
<code class="descname">scene_transform</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.scene_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The transform that maps from the current node to the first
scene in its ancestry.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.view_transform">
<code class="descname">view_transform</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.view_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The transform that maps from the current node to the first
viewbox in its ancestry.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.viewbox">
<code class="descname">viewbox</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.viewbox" title="Permalink to this definition">¶</a></dt>
<dd><p>The current viewbox.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.visual_to_canvas">
<code class="descname">visual_to_canvas</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.visual_to_canvas" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform mapping from visual local coordinate frame to canvas
coordinate frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.visual_to_document">
<code class="descname">visual_to_document</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.visual_to_document" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform mapping from visual local coordinate frame to document
coordinate frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneEvent.visual_to_framebuffer">
<code class="descname">visual_to_framebuffer</code><a class="headerlink" href="#vispy.scene.events.SceneEvent.visual_to_framebuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform mapping from visual coordinate frame to the framebuffer
(physical pixel) coordinate frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vispy.scene.events.SceneMouseEvent">
<em class="property">class </em><code class="descclassname">vispy.scene.events.</code><code class="descname">SceneMouseEvent</code><span class="sig-paren">(</span><em>event</em>, <em>canvas</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.events.SceneMouseEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#vispy.scene.events.SceneEvent" title="vispy.scene.events.SceneEvent"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.events.SceneEvent</span></code></a></p>
<p>Represents a mouse event that occurred on a SceneCanvas. This event is
delivered to all entities whose mouse interaction area is under the event.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">auto_configure</span></code>()</td>
<td>Automatically configure the TransformSystem:</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">copy</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">get_full_transform</span></code>()</td>
<td>Return the transform that maps from the current node to normalized device coordinates within the current glViewport and FBO.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">map_from_canvas</span></code>(obj)</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">map_to_canvas</span></code>(obj)</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>([map_to,&nbsp;map_from])</td>
<td>Return the transform from <em>map_from</em> to <em>map_to</em>, using the current node stack to resolve parent ambiguities if needed.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">pop_document</span></code>()</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">pop_fbo</span></code>()</td>
<td>Pop an FBO from the stack.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">pop_node</span></code>()</td>
<td>Pop an node from the stack.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">pop_viewbox</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">pop_viewport</span></code>()</td>
<td>Pop a viewport from the stack.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">push_document</span></code>(doc)</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">push_fbo</span></code>(viewport,&nbsp;fbo,&nbsp;transform)</td>
<td>Push an FBO on the stack, together with the new viewport.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">push_node</span></code>(node)</td>
<td>Push an node on the stack.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">push_viewbox</span></code>(viewbox)</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">push_viewport</span></code>(viewport)</td>
<td>Push a viewport (x, y, w, h) on the stack.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="vispy.scene.events.SceneMouseEvent.button">
<code class="descname">button</code><a class="headerlink" href="#vispy.scene.events.SceneMouseEvent.button" title="Permalink to this definition">¶</a></dt>
<dd><p>The button pressed or released on this event.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneMouseEvent.buttons">
<code class="descname">buttons</code><a class="headerlink" href="#vispy.scene.events.SceneMouseEvent.buttons" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of all buttons currently pressed on the mouse.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneMouseEvent.delta">
<code class="descname">delta</code><a class="headerlink" href="#vispy.scene.events.SceneMouseEvent.delta" title="Permalink to this definition">¶</a></dt>
<dd><p>The increment by which the mouse wheel has moved.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneMouseEvent.last_event">
<code class="descname">last_event</code><a class="headerlink" href="#vispy.scene.events.SceneMouseEvent.last_event" title="Permalink to this definition">¶</a></dt>
<dd><p>The mouse event immediately prior to this one. This
property is None when no mouse buttons are pressed.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneMouseEvent.pos">
<code class="descname">pos</code><a class="headerlink" href="#vispy.scene.events.SceneMouseEvent.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>The position of this event in the local coordinate system of the
visual.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.events.SceneMouseEvent.press_event">
<code class="descname">press_event</code><a class="headerlink" href="#vispy.scene.events.SceneMouseEvent.press_event" title="Permalink to this definition">¶</a></dt>
<dd><p>The mouse press event that initiated a mouse drag, if any.</p>
</dd></dl>

</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-vispy.scene.visuals">
<span id="vispy-scene-visuals"></span><h2>vispy.scene.visuals<a class="headerlink" href="#module-vispy.scene.visuals" title="Permalink to this headline">¶</a></h2>
<p>The classes in scene.visuals are visuals that may be added to a scenegraph
using the methods and properties defined in <cite>vispy.scene.Node</cite> such as name,
visible, parent, children, etc...</p>
<p>These classes are automatically generated by mixing <cite>vispy.scene.Node</cite> with
the Visual classes found in <cite>vispy.visuals</cite>.</p>
<p>For developing custom visuals, it is recommended to subclass from
<cite>vispy.visuals.Visual</cite> rather than <cite>vispy.scene.Node</cite>.</p>
<dl class="class">
<dt id="vispy.scene.visuals.Axis">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Axis</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.axis.AxisVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Axis visual</p>
<p>This class inherits from visuals.AxisVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pos</strong> : array</p>
<blockquote>
<div><p>Co-ordinates of start and end of the axis.</p>
</div></blockquote>
<p><strong>domain</strong> : tuple</p>
<blockquote>
<div><p>The data values at the beginning and end of the axis, used for tick
labels. i.e. (5, 10) means the axis starts at 5 and ends at 10. Default
is (0, 1).</p>
</div></blockquote>
<p><strong>tick_direction</strong> : array</p>
<blockquote>
<div><p>The tick direction to use (in document coordinates).</p>
</div></blockquote>
<p><strong>scale_type</strong> : str</p>
<blockquote>
<div><p>The type of scale. For now only 'linear' is supported.</p>
</div></blockquote>
<p><strong>axis_color</strong> : tuple</p>
<blockquote>
<div><p>RGBA values for the axis colour. Default is black.</p>
</div></blockquote>
<p><strong>tick_color</strong> : tuple</p>
<blockquote>
<div><p>RGBA values for the tick colours. The colour for the major and minor
ticks is currently fixed to be the same. Default is a dark grey.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote>
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Keyword arguments to pass to <cite>Visual</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id5"><span class="problematic" id="id6">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Box">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Box</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Box" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.box.BoxVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Visual that displays a box.</p>
<p>This class inherits from visuals.BoxVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>width</strong> : float</p>
<blockquote>
<div><p>Box width.</p>
</div></blockquote>
<p><strong>height</strong> : float</p>
<blockquote>
<div><p>Box height.</p>
</div></blockquote>
<p><strong>depth</strong> : float</p>
<blockquote>
<div><p>Box depth.</p>
</div></blockquote>
<p><strong>width_segments</strong> : int</p>
<blockquote>
<div><p>Box segments count along the width.</p>
</div></blockquote>
<p><strong>height_segments</strong> : float</p>
<blockquote>
<div><p>Box segments count along the height.</p>
</div></blockquote>
<p><strong>depth_segments</strong> : float</p>
<blockquote>
<div><p>Box segments count along the depth.</p>
</div></blockquote>
<p><strong>planes: array_like</strong> :</p>
<blockquote>
<div><p>Any combination of <code class="docutils literal"><span class="pre">{'-x',</span> <span class="pre">'+x',</span> <span class="pre">'-y',</span> <span class="pre">'+y',</span> <span class="pre">'-z',</span> <span class="pre">'+z'}</span></code>
Included planes in the box construction.</p>
</div></blockquote>
<p><strong>vertex_colors</strong> : ndarray</p>
<blockquote>
<div><p>Same as for <cite>MeshVisual</cite> class. See <cite>create_plane</cite> for vertex ordering.</p>
</div></blockquote>
<p><strong>face_colors</strong> : ndarray</p>
<blockquote>
<div><p>Same as for <cite>MeshVisual</cite> class. See <cite>create_plane</cite> for vertex ordering.</p>
</div></blockquote>
<p><strong>color</strong> : Color</p>
<blockquote>
<div><p>The <cite>Color</cite> to use when drawing the cube faces.</p>
</div></blockquote>
<p><strong>edge_color</strong> : tuple or Color</p>
<blockquote>
<div><p>The <cite>Color</cite> to use when drawing the cube edges. If <cite>None</cite>, then no
cube edges are drawn.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">mesh_data_changed</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>([vertices,&nbsp;faces,&nbsp;vertex_colors,&nbsp;...])</td>
<td>Set the mesh data</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id7"><span class="problematic" id="id8">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.ColorBar">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">ColorBar</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.ColorBar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.colorbar.ColorBarVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Visual subclass displaying a colorbar</p>
<p>This class inherits from visuals.ColorBarVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>center_pos</strong> : tuple (x, y)</p>
<blockquote>
<div><p>Position where the colorbar is to be placed with
respect to the center of the colorbar</p>
</div></blockquote>
<p><strong>halfdim</strong> : tuple (half_width, half_height)</p>
<blockquote>
<div><p>Half the dimensions of the colorbar measured
from the center. That way, the total dimensions
of the colorbar is (x - half_width) to (x + half_width)
and (y - half_height) to (y + half_height)</p>
</div></blockquote>
<p><strong>cmap</strong> : str | vispy.color.ColorMap</p>
<blockquote>
<div><p>Either the name of the ColorMap to be used from the standard
set of names (refer to <cite>vispy.color.get_colormap</cite>),
or a custom ColorMap object.
The ColorMap is used to apply a gradient on the colorbar.</p>
</div></blockquote>
<p><strong>orientation</strong> : {'left', 'right', 'top', 'bottom'}</p>
<blockquote>
<div><p>The orientation of the colorbar, used for rendering. The
orientation can be thought of as the position of the label
relative to the color bar.</p>
<p>When the orientation is 'left' or 'right', the colorbar is
vertically placed. When it is 'top' or 'bottom', the colorbar is
horizontally placed.</p>
<blockquote>
<div><ul class="simple">
<li>'top': the colorbar is horizontal.
Color is applied from left to right.
Minimum corresponds to left and maximum to right.
Label is to the top of the colorbar</li>
<li>'bottom': Same as top, except that
label is to the bottom of the colorbar</li>
<li>'left': the colorbar is vertical.
Color is applied from bottom to top.
Minimum corresponds to bottom and maximum to top.
Label is to the left of the colorbar</li>
<li>'right': Same as left, except that the
label is placed to the right of the colorbar</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>label_str</strong> : str</p>
<blockquote>
<div><p>The label that is to be drawn with the colorbar
that provides information about the colorbar.</p>
</div></blockquote>
<p><strong>clim</strong> : tuple (min, max)</p>
<blockquote>
<div><p>the minimum and maximum values of the data that
is given to the colorbar. This is used to draw the scale
on the side of the colorbar.</p>
</div></blockquote>
<p><strong>border_width</strong> : float (in px)</p>
<blockquote>
<div><p>The width of the border the colormap should have. This measurement
is given in pixels</p>
</div></blockquote>
<p><strong>border_color</strong> : str | vispy.color.Color</p>
<blockquote>
<div><p>The color of the border of the colormap. This can either be a
str as the color's name or an actual instace of a vipy.color.Color</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Return the (min, max) bounding values describing the location of this node in its local coordinate system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id9"><span class="problematic" id="id10">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Cube">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Cube</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.cube.CubeVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Visual that displays a cube or cuboid</p>
<p>This class inherits from visuals.CubeVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : float or tuple</p>
<blockquote>
<div><p>The size of the cuboid. A float gives a cube, whereas tuples may
specify the size of each axis (x, y, z) independently.</p>
</div></blockquote>
<p><strong>vertex_colors</strong> : ndarray</p>
<blockquote>
<div><p>Same as for <cite>MeshVisual</cite> class. See <cite>create_cube</cite> for vertex ordering.</p>
</div></blockquote>
<p><strong>face_colors</strong> : ndarray</p>
<blockquote>
<div><p>Same as for <cite>MeshVisual</cite> class. See <cite>create_cube</cite> for vertex ordering.</p>
</div></blockquote>
<p><strong>color</strong> : Color</p>
<blockquote>
<div><p>The <cite>Color</cite> to use when drawing the cube faces.</p>
</div></blockquote>
<p><strong>edge_color</strong> : tuple or Color</p>
<blockquote>
<div><p>The <cite>Color</cite> to use when drawing the cube edges. If <cite>None</cite>, then no
cube edges are drawn.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">mesh_data_changed</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>([vertices,&nbsp;faces,&nbsp;vertex_colors,&nbsp;...])</td>
<td>Set the mesh data</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id11"><span class="problematic" id="id12">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Ellipse">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Ellipse</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.ellipse.EllipseVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Displays a 2D ellipse</p>
<p>This class inherits from visuals.EllipseVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pos</strong> : array</p>
<blockquote>
<div><p>Center of the ellipse</p>
</div></blockquote>
<p><strong>color</strong> : instance of Color</p>
<blockquote>
<div><p>The face color to use.</p>
</div></blockquote>
<p><strong>border_color</strong> : instance of Color</p>
<blockquote>
<div><p>The border color to use.</p>
</div></blockquote>
<p><strong>radius</strong> : float | tuple</p>
<blockquote>
<div><p>Radius or radii of the ellipse
Defaults to  (0.1, 0.1)</p>
</div></blockquote>
<p><strong>start_angle</strong> : float</p>
<blockquote>
<div><p>Start angle of the ellipse in degrees
Defaults to 0.</p>
</div></blockquote>
<p><strong>span_angle</strong> : float</p>
<blockquote>
<div><p>Span angle of the ellipse in degrees
Defaults to 0.</p>
</div></blockquote>
<p><strong>num_segments</strong> : int</p>
<blockquote>
<div><p>Number of segments to be used to draw the ellipse
Defaults to 100</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Return the (min, max) bounding values describing the location of this node in its local coordinate system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_options</span></code>(*args,&nbsp;**kwargs)</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id13"><span class="problematic" id="id14">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_options</span></code>(*args,&nbsp;**kwargs)</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.GridLines">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">GridLines</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.GridLines" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.gridlines.GridLinesVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Displays regularly spaced grid lines in any coordinate system and at
any scale.</p>
<p>This class inherits from visuals.GridLinesVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>scale</strong> : tuple</p>
<blockquote>
<div><p>The scale to use.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Return the (min, max) bounding values describing the location of this node in its local coordinate system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id15"><span class="problematic" id="id16">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Histogram">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Histogram</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.histogram.HistogramVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Visual that calculates and displays a histogram of data</p>
<p>This class inherits from visuals.HistogramVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like</p>
<blockquote>
<div><p>Data to histogram. Currently only 1D data is supported.</p>
</div></blockquote>
<p><strong>bins</strong> : int | array-like</p>
<blockquote>
<div><p>Number of bins, or bin edges.</p>
</div></blockquote>
<p><strong>color</strong> : instance of Color</p>
<blockquote>
<div><p>Color of the histogram.</p>
</div></blockquote>
<p><strong>orientation</strong> : {'h', 'v'}</p>
<blockquote>
<div><p>Orientation of the histogram.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">mesh_data_changed</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>([vertices,&nbsp;faces,&nbsp;vertex_colors,&nbsp;...])</td>
<td>Set the mesh data</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id17"><span class="problematic" id="id18">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Image">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.image.ImageVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Visual subclass displaying an image.</p>
<p>This class inherits from visuals.ImageVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : ndarray</p>
<blockquote>
<div><p>ImageVisual data. Can be shape (M, N), (M, N, 3), or (M, N, 4).</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>Selects method of rendering image in case of non-linear transforms.
Each method produces similar results, but may trade efficiency
and accuracy. If the transform is linear, this parameter is ignored
and a single quad is drawn around the area of the image.</p>
<blockquote>
<div><ul class="simple">
<li>'auto': Automatically select 'impostor' if the image is drawn
with a nonlinear transform; otherwise select 'subdivide'.</li>
<li>'subdivide': ImageVisual is represented as a grid of triangles
with texture coordinates linearly mapped.</li>
<li>'impostor': ImageVisual is represented as a quad covering the
entire view, with texture coordinates determined by the
transform. This produces the best transformation results, but may
be slow.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>grid: tuple (rows, cols)</strong> :</p>
<blockquote>
<div><p>If method='subdivide', this tuple determines the number of rows and
columns in the image grid.</p>
</div></blockquote>
<p><strong>cmap</strong> : str | ColorMap</p>
<blockquote>
<div><p>Colormap to use for luminance images.</p>
</div></blockquote>
<p><strong>clim</strong> : str | tuple</p>
<blockquote>
<div><p>Limits to use for the colormap. Can be 'auto' to auto-set bounds to
the min and max of the data.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote>
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Keyword arguments to pass to <cite>Visual</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The colormap functionality through <code class="docutils literal"><span class="pre">cmap</span></code> and <code class="docutils literal"><span class="pre">clim</span></code> are only used
if the data are 2D.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>(image)</td>
<td>Set the data</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id19"><span class="problematic" id="id20">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Isocurve">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Isocurve</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Isocurve" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.isocurve.IsocurveVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Displays an isocurve of a 2D scalar array.</p>
<p>This class inherits from visuals.IsocurveVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : ndarray | None</p>
<blockquote>
<div><p>2D scalar array.</p>
</div></blockquote>
<p><strong>level: float | None</strong> :</p>
<blockquote>
<div><p>The level at which the isocurve is constructed from <em>data</em>.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>(data)</td>
<td>Set the scalar array data</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>(**kwargs)</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id21"><span class="problematic" id="id22">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(**kwargs)</td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Isoline">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Isoline</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Isoline" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.isoline.IsolineVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Isocurves of a tri mesh with data at vertices at different levels.</p>
<p>This class inherits from visuals.IsolineVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vertices</strong> : ndarray, shape (Nv, 3) | None</p>
<blockquote>
<div><p>Vertex coordinates.</p>
</div></blockquote>
<p><strong>tris</strong> : ndarray, shape (Nf, 3) | None</p>
<blockquote>
<div><p>Indices into the vertex array.</p>
</div></blockquote>
<p><strong>data</strong> : ndarray, shape (Nv,) | None</p>
<blockquote>
<div><p>scalar at vertices</p>
</div></blockquote>
<p><strong>levels</strong> : ndarray, shape (Nlev,) | None</p>
<blockquote>
<div><p>The levels at which the isocurve is constructed from &quot;data&quot;.</p>
</div></blockquote>
<p><strong>color_lev</strong> : Color, tuple, colormap name or array</p>
<blockquote>
<div><p>The color to use when drawing the line. If an array is given, it
must be of shape (Nlev, 4) and provide one rgba color by level.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote>
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Keyword arguments to pass to <cite>LineVisual</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_color</span></code>(color)</td>
<td>Set the color</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>([vertices,&nbsp;tris,&nbsp;data])</td>
<td>Set the data</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>(**kwargs)</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id23"><span class="problematic" id="id24">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(**kwargs)</td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Isosurface">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Isosurface</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Isosurface" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.isosurface.IsosurfaceVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Displays an isosurface of a 3D scalar array.</p>
<p>This class inherits from visuals.IsosurfaceVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : ndarray | None</p>
<blockquote>
<div><p>3D scalar array.</p>
</div></blockquote>
<p><strong>level: float | None</strong> :</p>
<blockquote>
<div><p>The level at which the isosurface is constructed from <em>data</em>.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">mesh_data_changed</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>(data)</td>
<td>Set the scalar array data</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id25"><span class="problematic" id="id26">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.LinePlot">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">LinePlot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.LinePlot" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.line_plot.LinePlotVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Visual displaying a plot line with optional markers.</p>
<p>This class inherits from visuals.LinePlotVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like</p>
<blockquote>
<div><p>Arguments can be passed as <code class="docutils literal"><span class="pre">(Y,)</span></code>, <code class="docutils literal"><span class="pre">(X,</span> <span class="pre">Y)</span></code> or
<code class="docutils literal"><span class="pre">np.array((X,</span> <span class="pre">Y))</span></code>.</p>
</div></blockquote>
<p><strong>color</strong> : instance of Color</p>
<blockquote>
<div><p>Color of the line.</p>
</div></blockquote>
<p><strong>symbol</strong> : str</p>
<blockquote>
<div><p>Marker symbol to use.</p>
</div></blockquote>
<p><strong>line_kind</strong> : str</p>
<blockquote>
<div><p>Kind of line to draw. For now, only solid lines (<code class="docutils literal"><span class="pre">'-'</span></code>)
are supported.</p>
</div></blockquote>
<p><strong>width</strong> : float</p>
<blockquote>
<div><p>Line width.</p>
</div></blockquote>
<p><strong>marker_size</strong> : float</p>
<blockquote>
<div><p>Marker size. If <cite>size == 0</cite> markers will not be shown.</p>
</div></blockquote>
<p><strong>edge_color</strong> : instance of Color</p>
<blockquote>
<div><p>Color of the marker edge.</p>
</div></blockquote>
<p><strong>face_color</strong> : instance of Color</p>
<blockquote>
<div><p>Color of the marker face.</p>
</div></blockquote>
<p><strong>edge_width</strong> : float</p>
<blockquote>
<div><p>Edge width of the marker.</p>
</div></blockquote>
<p><strong>connect</strong> : str | array</p>
<blockquote>
<div><p>See LineVisual.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote>
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
<p><strong>**kwargs</strong> : keyword arguments</p>
<blockquote class="last">
<div><p>Argements to pass to the super class.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">LineVisual</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">MarkersVisual</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">marker_types</span></code></p>
</div>
<p class="rubric">Examples</p>
<p>All of these syntaxes will work:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">LinePlotVisual</span><span class="p">(</span><span class="n">y_vals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LinePlotVisual</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="n">y_vals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LinePlotVisual</span><span class="p">(</span><span class="n">xy_vals</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>(data,&nbsp;**kwargs)</td>
<td>Set the line data</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id27"><span class="problematic" id="id28">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Line">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Line</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Line" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.line.line.LineVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Line visual</p>
<p>This class inherits from visuals.LineVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pos</strong> : array</p>
<blockquote>
<div><p>Array of shape (..., 2) or (..., 3) specifying vertex coordinates.</p>
</div></blockquote>
<p><strong>color</strong> : Color, tuple, or array</p>
<blockquote>
<div><p>The color to use when drawing the line. If an array is given, it
must be of shape (..., 4) and provide one rgba color per vertex.
Can also be a colormap name, or appropriate <cite>Function</cite>.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote>
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
<p><strong>width:</strong> :</p>
<blockquote>
<div><p>The width of the line in px. Line widths &gt; 1px are only
guaranteed to work when using 'agg' method.</p>
</div></blockquote>
<p><strong>connect</strong> : str or array</p>
<blockquote>
<div><p>Determines which vertices are connected by lines.</p>
<blockquote>
<div><ul class="simple">
<li>&quot;strip&quot; causes the line to be drawn with each vertex
connected to the next.</li>
<li>&quot;segments&quot; causes each pair of vertices to draw an
independent line segment</li>
<li>numpy arrays specify the exact set of segment pairs to
connect.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>Mode to use for drawing.</p>
<blockquote>
<div><ul class="simple">
<li>&quot;agg&quot; uses anti-grain geometry to draw nicely antialiased lines
with proper joins and endcaps.</li>
<li>&quot;gl&quot; uses OpenGL's built-in line rendering. This is much faster,
but produces much lower-quality results and is not guaranteed to
obey the requested line width or join/endcap styles.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>antialias</strong> : bool</p>
<blockquote class="last">
<div><p>Enables or disables antialiasing.
For method='gl', this specifies whether to use GL's line smoothing, 
which may be unavailable or inconsistent on some platforms.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>([pos,&nbsp;color,&nbsp;width,&nbsp;connect])</td>
<td>Set the data used to draw this visual.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>(**kwargs)</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id29"><span class="problematic" id="id30">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(**kwargs)</td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Markers">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Markers</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Markers" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.markers.MarkersVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Visual displaying marker symbols.</p>
<p>This class inherits from visuals.MarkersVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>([pos,&nbsp;symbol,&nbsp;size,&nbsp;edge_width,&nbsp;...])</td>
<td>Set the data used to display this visual.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_symbol</span></code>([symbol])</td>
<td>Set the symbol</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id31"><span class="problematic" id="id32">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Mesh">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Mesh</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.mesh.MeshVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Mesh visual</p>
<p>This class inherits from visuals.MeshVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vertices</strong> : array-like | None</p>
<blockquote>
<div><p>The vertices.</p>
</div></blockquote>
<p><strong>faces</strong> : array-like | None</p>
<blockquote>
<div><p>The faces.</p>
</div></blockquote>
<p><strong>vertex_colors</strong> : array-like | None</p>
<blockquote>
<div><p>Colors to use for each vertex.</p>
</div></blockquote>
<p><strong>face_colors</strong> : array-like | None</p>
<blockquote>
<div><p>Colors to use for each face.</p>
</div></blockquote>
<p><strong>color</strong> : instance of Color</p>
<blockquote>
<div><p>The color to use.</p>
</div></blockquote>
<p><strong>meshdata</strong> : instance of MeshData | None</p>
<blockquote>
<div><p>The meshdata.</p>
</div></blockquote>
<p><strong>shading</strong> : str | None</p>
<blockquote>
<div><p>Shading to use.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>The drawing mode.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote>
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Keyword arguments to pass to <cite>Visual</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">mesh_data_changed</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>([vertices,&nbsp;faces,&nbsp;vertex_colors,&nbsp;...])</td>
<td>Set the mesh data</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id33"><span class="problematic" id="id34">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Plane">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Plane</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.plane.PlaneVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Visual that displays a plane.</p>
<p>This class inherits from visuals.PlaneVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>width</strong> : float</p>
<blockquote>
<div><p>Plane width.</p>
</div></blockquote>
<p><strong>height</strong> : float</p>
<blockquote>
<div><p>Plane height.</p>
</div></blockquote>
<p><strong>width_segments</strong> : int</p>
<blockquote>
<div><p>Plane segments count along the width.</p>
</div></blockquote>
<p><strong>height_segments</strong> : float</p>
<blockquote>
<div><p>Plane segments count along the height.</p>
</div></blockquote>
<p><strong>direction: unicode</strong> :</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">{'-x',</span> <span class="pre">'+x',</span> <span class="pre">'-y',</span> <span class="pre">'+y',</span> <span class="pre">'-z',</span> <span class="pre">'+z'}</span></code>
Direction the plane will be facing.</p>
</div></blockquote>
<p><strong>vertex_colors</strong> : ndarray</p>
<blockquote>
<div><p>Same as for <cite>MeshVisual</cite> class. See <cite>create_plane</cite> for vertex ordering.</p>
</div></blockquote>
<p><strong>face_colors</strong> : ndarray</p>
<blockquote>
<div><p>Same as for <cite>MeshVisual</cite> class. See <cite>create_plane</cite> for vertex ordering.</p>
</div></blockquote>
<p><strong>color</strong> : Color</p>
<blockquote>
<div><p>The <cite>Color</cite> to use when drawing the cube faces.</p>
</div></blockquote>
<p><strong>edge_color</strong> : tuple or Color</p>
<blockquote>
<div><p>The <cite>Color</cite> to use when drawing the cube edges. If <cite>None</cite>, then no
cube edges are drawn.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">mesh_data_changed</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>([vertices,&nbsp;faces,&nbsp;vertex_colors,&nbsp;...])</td>
<td>Set the mesh data</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id35"><span class="problematic" id="id36">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Polygon">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Polygon</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.polygon.PolygonVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Displays a 2D polygon</p>
<p>This class inherits from visuals.PolygonVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pos</strong> : array</p>
<blockquote>
<div><p>Set of vertices defining the polygon.</p>
</div></blockquote>
<p><strong>color</strong> : str | tuple | list of colors</p>
<blockquote>
<div><p>Fill color of the polygon.</p>
</div></blockquote>
<p><strong>border_color</strong> : str | tuple | list of colors</p>
<blockquote>
<div><p>Border color of the polygon.</p>
</div></blockquote>
<p><strong>border_width</strong> : int</p>
<blockquote>
<div><p>Border width in pixels.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote>
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Keyword arguments to pass to <cite>PolygonVisual</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Return the (min, max) bounding values describing the location of this node in its local coordinate system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_options</span></code>(*args,&nbsp;**kwargs)</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id37"><span class="problematic" id="id38">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_options</span></code>(*args,&nbsp;**kwargs)</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Rectangle">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Rectangle</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.rectangle.RectangleVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Displays a 2D rectangle with optional rounded corners</p>
<p>This class inherits from visuals.RectangleVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pos</strong> :  array</p>
<blockquote>
<div><p>Center of the rectangle</p>
</div></blockquote>
<p><strong>color</strong> : instance of Color</p>
<blockquote>
<div><p>The fill color to use.</p>
</div></blockquote>
<p><strong>border_color</strong> : instance of Color</p>
<blockquote>
<div><p>The border color to use.</p>
</div></blockquote>
<p><strong>height</strong> : float</p>
<blockquote>
<div><p>Length of the rectangle along y-axis
Defaults to 1.0</p>
</div></blockquote>
<p><strong>width</strong> : float</p>
<blockquote>
<div><p>Length of the rectangle along x-axis
Defaults to 1.0</p>
</div></blockquote>
<p><strong>radius</strong> : float | array</p>
<blockquote>
<div><p>Radii of curvatures of corners in clockwise order from top-left
Defaults to 0.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Return the (min, max) bounding values describing the location of this node in its local coordinate system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_options</span></code>(*args,&nbsp;**kwargs)</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id39"><span class="problematic" id="id40">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_options</span></code>(*args,&nbsp;**kwargs)</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.RegularPolygon">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">RegularPolygon</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.RegularPolygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.regular_polygon.RegularPolygonVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Displays a regular polygon</p>
<p>This class inherits from visuals.RegularPolygonVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pos</strong> : array</p>
<blockquote>
<div><p>Center of the regular polygon</p>
</div></blockquote>
<p><strong>color</strong> : str | tuple | list of colors</p>
<blockquote>
<div><p>Fill color of the polygon</p>
</div></blockquote>
<p><strong>border_color</strong> : str | tuple | list of colors</p>
<blockquote>
<div><p>Border color of the polygon</p>
</div></blockquote>
<p><strong>radius</strong> : float</p>
<blockquote>
<div><p>Radius of the regular polygon
Defaults to  0.1</p>
</div></blockquote>
<p><strong>sides</strong> : int</p>
<blockquote>
<div><p>Number of sides of the regular polygon</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Return the (min, max) bounding values describing the location of this node in its local coordinate system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_options</span></code>(*args,&nbsp;**kwargs)</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id41"><span class="problematic" id="id42">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_options</span></code>(*args,&nbsp;**kwargs)</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Spectrogram">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Spectrogram</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Spectrogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.spectrogram.SpectrogramVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Calculate and show a spectrogram</p>
<p>This class inherits from visuals.SpectrogramVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like</p>
<blockquote>
<div><p>1D signal to operate on. <code class="docutils literal"><span class="pre">If</span> <span class="pre">len(x)</span> <span class="pre">&lt;</span> <span class="pre">n_fft</span></code>, x will be
zero-padded to length <code class="docutils literal"><span class="pre">n_fft</span></code>.</p>
</div></blockquote>
<p><strong>n_fft</strong> : int</p>
<blockquote>
<div><p>Number of FFT points. Much faster for powers of two.</p>
</div></blockquote>
<p><strong>step</strong> : int | None</p>
<blockquote>
<div><p>Step size between calculations. If None, <code class="docutils literal"><span class="pre">n_fft</span> <span class="pre">//</span> <span class="pre">2</span></code>
will be used.</p>
</div></blockquote>
<p><strong>fs</strong> : float</p>
<blockquote>
<div><p>The sample rate of the data.</p>
</div></blockquote>
<p><strong>window</strong> : str | None</p>
<blockquote>
<div><p>Window function to use. Can be <code class="docutils literal"><span class="pre">'hann'</span></code> for Hann window, or None
for no windowing.</p>
</div></blockquote>
<p><strong>color_scale</strong> : {'linear', 'log'}</p>
<blockquote>
<div><p>Scale to apply to the result of the STFT.
<code class="docutils literal"><span class="pre">'log'</span></code> will use <code class="docutils literal"><span class="pre">10</span> <span class="pre">*</span> <span class="pre">log10(power)</span></code>.</p>
</div></blockquote>
<p><strong>cmap</strong> : str</p>
<blockquote>
<div><p>Colormap name.</p>
</div></blockquote>
<p><strong>clim</strong> : str | tuple</p>
<blockquote>
<div><p>Colormap limits. Should be <code class="docutils literal"><span class="pre">'auto'</span></code> or a two-element tuple of
min and max values.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>(image)</td>
<td>Set the data</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id43"><span class="problematic" id="id44">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.SurfacePlot">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">SurfacePlot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.SurfacePlot" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.surface_plot.SurfacePlotVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Displays a surface plot on a regular x,y grid</p>
<p>This class inherits from visuals.SurfacePlotVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : ndarray | None</p>
<blockquote>
<div><p>1D array of values specifying the x positions of vertices in the
grid. If None, values will be assumed to be integers.</p>
</div></blockquote>
<p><strong>y</strong> : ndarray | None</p>
<blockquote>
<div><p>1D array of values specifying the x positions of vertices in the
grid. If None, values will be assumed to be integers.</p>
</div></blockquote>
<p><strong>z</strong> : ndarray</p>
<blockquote>
<div><p>2D array of height values for each grid vertex.</p>
</div></blockquote>
<p><strong>colors</strong> : ndarray</p>
<blockquote>
<div><p>(width, height, 4) array of vertex colors.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>All arguments are optional.</p>
<p>Note that if vertex positions are updated, the normal vectors for each
triangle must be recomputed. This is somewhat expensive if the surface
was initialized with smooth=False and very expensive if smooth=True.
For faster performance, initialize with compute_normals=False and use
per-vertex colors or a material that does not require normals.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">generate_faces</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">mesh_data_changed</span></code>()</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>([x,&nbsp;y,&nbsp;z,&nbsp;colors])</td>
<td>Update the data in this surface plot.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id45"><span class="problematic" id="id46">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Text">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Text</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Text" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.text.text.TextVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Visual that displays text</p>
<p>This class inherits from visuals.TextVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>text</strong> : str | list of str</p>
<blockquote>
<div><p>Text to display. Can also be a list of strings.
Note: support for list of str might be removed soon
in favor of text collections.</p>
</div></blockquote>
<p><strong>color</strong> : instance of Color</p>
<blockquote>
<div><p>Color to use.</p>
</div></blockquote>
<p><strong>bold</strong> : bool</p>
<blockquote>
<div><p>Bold face.</p>
</div></blockquote>
<p><strong>italic</strong> : bool</p>
<blockquote>
<div><p>Italic face.</p>
</div></blockquote>
<p><strong>face</strong> : str</p>
<blockquote>
<div><p>Font face to use.</p>
</div></blockquote>
<p><strong>font_size</strong> : float</p>
<blockquote>
<div><p>Point size to use.</p>
</div></blockquote>
<p><strong>pos</strong> : tuple | list of tuple</p>
<blockquote>
<div><p>Position (x, y) or (x, y, z) of the text.
Can also be a list of tuple if <cite>text</cite> is a list.</p>
</div></blockquote>
<p><strong>rotation</strong> : float</p>
<blockquote>
<div><p>Rotation (in degrees) of the text clockwise.</p>
</div></blockquote>
<p><strong>anchor_x</strong> : str</p>
<blockquote>
<div><p>Horizontal text anchor.</p>
</div></blockquote>
<p><strong>anchor_y</strong> : str</p>
<blockquote>
<div><p>Vertical text anchor.</p>
</div></blockquote>
<p><strong>font_manager</strong> : object | None</p>
<blockquote>
<div><p>Font manager to use (can be shared if the GLContext is shared).</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Return the (min, max) bounding values describing the location of this node in its local coordinate system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the Text</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id47"><span class="problematic" id="id48">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Tube">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Tube</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Tube" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.tube.TubeVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Displays a tube around a piecewise-linear path.</p>
<p>This class inherits from visuals.TubeVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<p>The tube mesh is corrected following its Frenet curvature and
torsion such that it varies smoothly along the curve, including if
the tube is closed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>points</strong> : ndarray</p>
<blockquote>
<div><p>An array of (x, y, z) points describing the path along which the
tube will be extruded.</p>
</div></blockquote>
<p><strong>radius</strong> : float</p>
<blockquote>
<div><p>The radius of the tube. Defaults to 1.0.</p>
</div></blockquote>
<p><strong>closed</strong> : bool</p>
<blockquote>
<div><p>Whether the tube should be closed, joining the last point to the
first. Defaults to False.</p>
</div></blockquote>
<p><strong>color</strong> : Color | ColorArray</p>
<blockquote>
<div><p>The color(s) to use when drawing the tube. The same color is
applied to each vertex of the mesh surrounding each point of
the line. If the input is a ColorArray, the argument will be
cycled; for instance if 'red' is passed then the entire tube
will be red, or if ['green', 'blue'] is passed then the points
will alternate between these colours. Defaults to 'purple'.</p>
</div></blockquote>
<p><strong>tube_points</strong> : int</p>
<blockquote>
<div><p>The number of points in the circle-approximating polygon of the
tube's cross section. Defaults to 8.</p>
</div></blockquote>
<p><strong>shading</strong> : str | None</p>
<blockquote>
<div><p>Same as for the <cite>MeshVisual</cite> class. Defaults to 'smooth'.</p>
</div></blockquote>
<p><strong>vertex_colors: ndarray | None</strong> :</p>
<blockquote>
<div><p>Same as for the <cite>MeshVisual</cite> class.</p>
</div></blockquote>
<p><strong>face_colors: ndarray | None</strong> :</p>
<blockquote>
<div><p>Same as for the <cite>MeshVisual</cite> class.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>Same as for the <cite>MeshVisual</cite> class. Defaults to 'triangles'.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">mesh_data_changed</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>([vertices,&nbsp;faces,&nbsp;vertex_colors,&nbsp;...])</td>
<td>Set the mesh data</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id49"><span class="problematic" id="id50">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.Volume">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">Volume</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.volume.VolumeVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Displays a 3D Volume</p>
<p>This class inherits from visuals.VolumeVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vol</strong> : ndarray</p>
<blockquote>
<div><p>The volume to display. Must be ndim==3.</p>
</div></blockquote>
<p><strong>clim</strong> : tuple of two floats | None</p>
<blockquote>
<div><p>The contrast limits. The values in the volume are mapped to
black and white corresponding to these values. Default maps
between min and max.</p>
</div></blockquote>
<p><strong>method</strong> : {'mip', 'translucent', 'additive', 'iso'}</p>
<blockquote>
<div><p>The render method to use. See corresponding docs for details.
Default 'mip'.</p>
</div></blockquote>
<p><strong>threshold</strong> : float</p>
<blockquote>
<div><p>The threshold to use for the isosurafce render method. By default
the mean of the given volume is used.</p>
</div></blockquote>
<p><strong>relative_step_size</strong> : float</p>
<blockquote>
<div><p>The relative step size to step through the volume. Default 0.8.
Increase to e.g. 1.5 to increase performance, at the cost of
quality.</p>
</div></blockquote>
<p><strong>cmap</strong> : str</p>
<blockquote>
<div><p>Colormap to use.</p>
</div></blockquote>
<p><strong>emulate_texture</strong> : bool</p>
<blockquote>
<div><p>Use 2D textures to emulate a 3D texture. OpenGL ES 2.0 compatible,
but has lower performance on desktop platforms.</p>
</div></blockquote>
<p><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the visual bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>(vol[,&nbsp;clim])</td>
<td>Set the volume data.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>([preset])</td>
<td>Define the set of GL state parameters to use when drawing</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id51"><span class="problematic" id="id52">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(*args,&nbsp;**kwargs)</td>
<td>Modify the set of GL state parameters to use when drawing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="vispy.scene.visuals.XYZAxis">
<em class="property">class </em><code class="descclassname">vispy.scene.visuals.</code><code class="descname">XYZAxis</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.visuals.XYZAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.visuals.xyz_axis.XYZAxisVisual</span></code>, <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>Simple 3D axis for indicating coordinate system orientation. Axes are
x=red, y=green, z=blue.</p>
<p>This class inherits from visuals.XYZAxisVisual and scene.Node, allowing the visual to be placed inside a scenegraph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parent</strong> : Node</p>
<blockquote>
<div><p>The parent node to assign to this node (optional).</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote class="last">
<div><p>A name for this node, used primarily for debugging
(optional).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code>(filt)</td>
<td>Attach a Filter to this visual</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">bounds</span></code>(mode,&nbsp;axis)</td>
<td>Get the bounds</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">detach</span></code>(filt)</td>
<td>Detach a filter</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(transforms)</td>
<td>Draw the visual</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_data</span></code>([pos,&nbsp;color,&nbsp;width,&nbsp;connect])</td>
<td>Set the data used to draw this visual.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_gl_state</span></code>(**kwargs)</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id53"><span class="problematic" id="id54">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that this Visual needs to be redrawn.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update_gl_state</span></code>(**kwargs)</td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-vispy.scene.widgets">
<span id="vispy-scene-widgets"></span><h2>vispy.scene.widgets<a class="headerlink" href="#module-vispy.scene.widgets" title="Permalink to this headline">¶</a></h2>
<p>The vispy.scene.widgets namespace provides a range of widgets to allow
user interaction. Widgets are rectangular Visual objects such as buttons
and sliders.</p>
<dl class="class">
<dt id="vispy.scene.widgets.Console">
<em class="property">class </em><code class="descclassname">vispy.scene.widgets.</code><code class="descname">Console</code><span class="sig-paren">(</span><em>text_color='black'</em>, <em>font_size=12.0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Console" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.scene.widgets.widget.Widget</span></code></p>
<p>Fast and failsafe text console</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>text_color</strong> : instance of Color</p>
<blockquote>
<div><p>Color to use.</p>
</div></blockquote>
<p><strong>font_size</strong> : float</p>
<blockquote class="last">
<div><p>Point size to use.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_grid</span></code>(*args,&nbsp;**kwargs)</td>
<td>Create a new Grid and add it as a child widget.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_view</span></code>(*args,&nbsp;**kwargs)</td>
<td>Create a new ViewBox and add it as a child widget.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">add_widget</span></code>(widget)</td>
<td>Add a Widget as a managed child of this Widget.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.widgets.Console.clear" title="vispy.scene.widgets.Console.clear"><code class="xref py py-obj docutils literal"><span class="pre">clear</span></code></a>()</td>
<td>Clear the console</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.widgets.Console.draw" title="vispy.scene.widgets.Console.draw"><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code></a>(event)</td>
<td>Draw the widget</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">on_resize</span></code>(event)</td>
<td>On resize handler</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_widget</span></code>(widget)</td>
<td>Remove a Widget as a managed child of this Widget.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id55"><span class="problematic" id="id56">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that properties of this Node or its children have changed.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.widgets.Console.write" title="vispy.scene.widgets.Console.write"><code class="xref py py-obj docutils literal"><span class="pre">write</span></code></a>([text,&nbsp;wrap])</td>
<td>Write text and scroll</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="vispy.scene.widgets.Console.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Console.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the console</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.widgets.Console.draw">
<code class="descname">draw</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Console.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw the widget</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : instance of Event</p>
<blockquote class="last">
<div><p>The draw event.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.widgets.Console.font_size">
<code class="descname">font_size</code><a class="headerlink" href="#vispy.scene.widgets.Console.font_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The font size (in points) of the text</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.widgets.Console.text_color">
<code class="descname">text_color</code><a class="headerlink" href="#vispy.scene.widgets.Console.text_color" title="Permalink to this definition">¶</a></dt>
<dd><p>The color of the text</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.widgets.Console.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>text=''</em>, <em>wrap=True</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Console.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write text and scroll</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>text</strong> : str</p>
<blockquote>
<div><p>Text to write. <code class="docutils literal"><span class="pre">''</span></code> can be used for a blank line, as a newline
is automatically added to the end of each line.</p>
</div></blockquote>
<p><strong>wrap</strong> : str</p>
<blockquote class="last">
<div><p>If True, long messages will be wrapped to span multiple lines.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vispy.scene.widgets.Grid">
<em class="property">class </em><code class="descclassname">vispy.scene.widgets.</code><code class="descname">Grid</code><span class="sig-paren">(</span><em>spacing=6</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.scene.widgets.widget.Widget</span></code></p>
<p>Widget that automatically sets the position and size of child Widgets to
proportionally divide its internal area into a grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>spacing</strong> : int</p>
<blockquote>
<div><p>Spacing between widgets.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Keyword arguments to pass to <cite>Widget</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.widgets.Grid.add_grid" title="vispy.scene.widgets.Grid.add_grid"><code class="xref py py-obj docutils literal"><span class="pre">add_grid</span></code></a>([row,&nbsp;col,&nbsp;row_span,&nbsp;col_span])</td>
<td>Create a new Grid and add it as a child widget.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.widgets.Grid.add_view" title="vispy.scene.widgets.Grid.add_view"><code class="xref py py-obj docutils literal"><span class="pre">add_view</span></code></a>([row,&nbsp;col,&nbsp;row_span,&nbsp;col_span])</td>
<td>Create a new ViewBox and add it as a child widget.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.widgets.Grid.add_widget" title="vispy.scene.widgets.Grid.add_widget"><code class="xref py py-obj docutils literal"><span class="pre">add_widget</span></code></a>([widget,&nbsp;row,&nbsp;col,&nbsp;row_span,&nbsp;...])</td>
<td>Add a new widget to this grid.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code>(event)</td>
<td>Draw the widget borders</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">next_row</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">on_resize</span></code>(event)</td>
<td>On resize handler</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_widget</span></code>(widget)</td>
<td>Remove a Widget as a managed child of this Widget.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id57"><span class="problematic" id="id58">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that properties of this Node or its children have changed.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="vispy.scene.widgets.Grid.add_grid">
<code class="descname">add_grid</code><span class="sig-paren">(</span><em>row=None</em>, <em>col=None</em>, <em>row_span=1</em>, <em>col_span=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Grid.add_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new Grid and add it as a child widget.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>row</strong> : int</p>
<blockquote>
<div><p>The row in which to add the widget (0 is the topmost row)</p>
</div></blockquote>
<p><strong>col</strong> : int</p>
<blockquote>
<div><p>The column in which to add the widget (0 is the leftmost column)</p>
</div></blockquote>
<p><strong>row_span</strong> : int</p>
<blockquote>
<div><p>The number of rows to be occupied by this widget. Default is 1.</p>
</div></blockquote>
<p><strong>col_span</strong> : int</p>
<blockquote>
<div><p>The number of columns to be occupied by this widget. Default is 1.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Keyword arguments to pass to the new <cite>Grid</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.widgets.Grid.add_view">
<code class="descname">add_view</code><span class="sig-paren">(</span><em>row=None</em>, <em>col=None</em>, <em>row_span=1</em>, <em>col_span=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Grid.add_view" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new ViewBox and add it as a child widget.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>row</strong> : int</p>
<blockquote>
<div><p>The row in which to add the widget (0 is the topmost row)</p>
</div></blockquote>
<p><strong>col</strong> : int</p>
<blockquote>
<div><p>The column in which to add the widget (0 is the leftmost column)</p>
</div></blockquote>
<p><strong>row_span</strong> : int</p>
<blockquote>
<div><p>The number of rows to be occupied by this widget. Default is 1.</p>
</div></blockquote>
<p><strong>col_span</strong> : int</p>
<blockquote>
<div><p>The number of columns to be occupied by this widget. Default is 1.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Keyword arguments to pass to <cite>ViewBox</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.widgets.Grid.add_widget">
<code class="descname">add_widget</code><span class="sig-paren">(</span><em>widget=None</em>, <em>row=None</em>, <em>col=None</em>, <em>row_span=1</em>, <em>col_span=1</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Grid.add_widget" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new widget to this grid. This will cause other widgets in the
grid to be resized to make room for the new widget.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>widget</strong> : Widget</p>
<blockquote>
<div><p>The Widget to add</p>
</div></blockquote>
<p><strong>row</strong> : int</p>
<blockquote>
<div><p>The row in which to add the widget (0 is the topmost row)</p>
</div></blockquote>
<p><strong>col</strong> : int</p>
<blockquote>
<div><p>The column in which to add the widget (0 is the leftmost column)</p>
</div></blockquote>
<p><strong>row_span</strong> : int</p>
<blockquote>
<div><p>The number of rows to be occupied by this widget. Default is 1.</p>
</div></blockquote>
<p><strong>col_span</strong> : int</p>
<blockquote class="last">
<div><p>The number of columns to be occupied by this widget. Default is 1.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The widget's parent is automatically set to this grid, and all other
parent(s) are removed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vispy.scene.widgets.ViewBox">
<em class="property">class </em><code class="descclassname">vispy.scene.widgets.</code><code class="descname">ViewBox</code><span class="sig-paren">(</span><em>camera=None</em>, <em>scene=None</em>, <em>clip_method='fragment'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.ViewBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">vispy.scene.widgets.widget.Widget</span></code></p>
<p>Provides a rectangular widget to which its subscene is rendered.</p>
<p>Three classes work together when using a ViewBox:
* The <code class="xref py py-class docutils literal"><span class="pre">SubScene</span></code> class describes a &quot;world&quot; coordinate system and the
entities that live inside it.
* ViewBox is a &quot;window&quot; through which we view the
subscene. Multiple ViewBoxes may view the same subscene.
* <code class="xref py py-class docutils literal"><span class="pre">Camera</span></code> describes both the perspective from which the
subscene is rendered, and the way user interaction affects that
perspective.</p>
<p>In general it is only necessary to create the ViewBox; a SubScene and
Camera will be generated automatically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>camera</strong> : None, <code class="xref py py-class docutils literal"><span class="pre">Camera</span></code>, or str</p>
<blockquote>
<div><p>The camera through which to view the SubScene. If None, then a
PanZoomCamera (2D interaction) is used. If str, then the string is
used as the argument to <code class="xref py py-func docutils literal"><span class="pre">make_camera()</span></code>.</p>
</div></blockquote>
<p><strong>scene</strong> : None or <code class="xref py py-class docutils literal"><span class="pre">SubScene</span></code></p>
<blockquote>
<div><p>The <cite>SubScene</cite> instance to view. If None, a new <cite>SubScene</cite> is created.</p>
</div></blockquote>
<p><strong>clip_method</strong> : str</p>
<blockquote>
<div><p>Clipping method to use.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Extra keyword arguments to pass to <cite>Widget</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.widgets.ViewBox.add" title="vispy.scene.widgets.ViewBox.add"><code class="xref py py-obj docutils literal"><span class="pre">add</span></code></a>(node)</td>
<td>Add an Node to the scene for this ViewBox.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">add_grid</span></code>(*args,&nbsp;**kwargs)</td>
<td>Create a new Grid and add it as a child widget.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">add_view</span></code>(*args,&nbsp;**kwargs)</td>
<td>Create a new ViewBox and add it as a child widget.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_widget</span></code>(widget)</td>
<td>Add a Widget as a managed child of this Widget.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.widgets.ViewBox.draw" title="vispy.scene.widgets.ViewBox.draw"><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code></a>(event)</td>
<td>Draw the viewbox border/background</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.widgets.ViewBox.get_scene_bounds" title="vispy.scene.widgets.ViewBox.get_scene_bounds"><code class="xref py py-obj docutils literal"><span class="pre">get_scene_bounds</span></code></a>([dim])</td>
<td>Get the total bounds based on the visuals present in the scene</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.widgets.ViewBox.is_in_scene" title="vispy.scene.widgets.ViewBox.is_in_scene"><code class="xref py py-obj docutils literal"><span class="pre">is_in_scene</span></code></a>(node)</td>
<td>Get whether the given node is inside the scene of this viewbox.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">on_resize</span></code>(event)</td>
<td>On resize handler</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_widget</span></code>(widget)</td>
<td>Remove a Widget as a managed child of this Widget.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id59"><span class="problematic" id="id60">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that properties of this Node or its children have changed.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="vispy.scene.widgets.ViewBox.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.ViewBox.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an Node to the scene for this ViewBox.</p>
<p>This is a convenience method equivalent to
<cite>node.add_parent(viewbox.scene)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : instance of Node</p>
<blockquote class="last">
<div><p>The node to add.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.widgets.ViewBox.camera">
<code class="descname">camera</code><a class="headerlink" href="#vispy.scene.widgets.ViewBox.camera" title="Permalink to this definition">¶</a></dt>
<dd><p>Get/set the Camera in use by this ViewBox</p>
<p>If a string is given (e.g. 'panzoom', 'turntable', 'fly'). A
corresponding camera is selected if it already exists in the
scene, otherwise a new camera is created.</p>
<p>The camera object is made a child of the scene (if it is not
already in the scene).</p>
<p>Multiple cameras can exist in one scene, although only one can
be active at a time. A single camera can be used by multiple
viewboxes at the same time.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.widgets.ViewBox.clip_method">
<code class="descname">clip_method</code><a class="headerlink" href="#vispy.scene.widgets.ViewBox.clip_method" title="Permalink to this definition">¶</a></dt>
<dd><p>The method used to clip the subscene to the boundaries of the 
viewbox.</p>
<p>Clipping methods are:</p>
<ul class="simple">
<li>None - do not perform clipping. The default for now.</li>
<li>'viewport' - use glViewPort to provide a clipped sub-grid
onto the parent pixel grid, if possible.</li>
<li>'fbo' - use an FBO to draw the subscene to a texture, and
then render the texture in the parent scene.</li>
<li>'fragment' - clipping in the fragment shader</li>
<li>'stencil' - TODO</li>
</ul>
<p class="rubric">Notes</p>
<p>The 'viewport' method requires that the transformation (from
the pixel grid to this viewbox) is translate+scale only. If
this is not the case, the method falls back to the default.</p>
<p>The 'fbo' method is convenient when the result of the viewbox
should be reused. Otherwise the overhead can be significant and
the image can get slightly blurry if the transformations do
not match.</p>
<p>It is possible to have a graph with multiple stacked viewboxes
which each use different methods (subject to the above
restrictions).</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.widgets.ViewBox.draw">
<code class="descname">draw</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.ViewBox.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw the viewbox border/background</p>
<p>This also prepares to draw the
subscene using the configured clipping method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : instance of Event</p>
<blockquote class="last">
<div><p>The draw event.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.widgets.ViewBox.get_scene_bounds">
<code class="descname">get_scene_bounds</code><span class="sig-paren">(</span><em>dim=None</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.ViewBox.get_scene_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the total bounds based on the visuals present in the scene</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dim</strong> : int | None</p>
<blockquote>
<div><p>Dimension to return.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bounds</strong> : list | tuple</p>
<blockquote class="last">
<div><p>If <code class="docutils literal"><span class="pre">dim</span> <span class="pre">is</span> <span class="pre">None</span></code>, Returns a list of 3 tuples, otherwise
the bounds for the requested dimension.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.widgets.ViewBox.is_in_scene">
<code class="descname">is_in_scene</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.ViewBox.is_in_scene" title="Permalink to this definition">¶</a></dt>
<dd><p>Get whether the given node is inside the scene of this viewbox.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : instance of Node</p>
<blockquote class="last">
<div><p>The node.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.widgets.ViewBox.scene">
<code class="descname">scene</code><a class="headerlink" href="#vispy.scene.widgets.ViewBox.scene" title="Permalink to this definition">¶</a></dt>
<dd><p>The root node of the scene viewed by this ViewBox.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vispy.scene.widgets.Widget">
<em class="property">class </em><code class="descclassname">vispy.scene.widgets.</code><code class="descname">Widget</code><span class="sig-paren">(</span><em>pos=(0</em>, <em>0)</em>, <em>size=(10</em>, <em>10)</em>, <em>border_color=None</em>, <em>bgcolor=None</em>, <em>clip=False</em>, <em>padding=0</em>, <em>margin=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Widget" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#vispy.scene.node.Node" title="vispy.scene.node.Node"><code class="xref py py-class docutils literal"><span class="pre">vispy.scene.node.Node</span></code></a></p>
<p>A widget takes up a rectangular space, intended for use in
a 2D pixel coordinate frame.</p>
<p>The widget is positioned using the transform attribute (as any
node), and its extent (size) is kept as a separate property.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pos</strong> : (x, y)</p>
<blockquote>
<div><p>A 2-element tuple to specify the top left corner of the widget.</p>
</div></blockquote>
<p><strong>size</strong> : (w, h)</p>
<blockquote>
<div><p>A 2-element tuple to spicify the size of the widget.</p>
</div></blockquote>
<p><strong>border_color</strong> : color</p>
<blockquote>
<div><p>The color of the border.</p>
</div></blockquote>
<p><strong>bgcolor</strong> : color</p>
<blockquote>
<div><p>The background color.</p>
</div></blockquote>
<p><strong>clip</strong> : bool</p>
<blockquote>
<div><p>Not used :)</p>
</div></blockquote>
<p><strong>padding</strong> : int</p>
<blockquote>
<div><p>The amount of padding in the widget (i.e. the space reserved between
the contents and the border).</p>
</div></blockquote>
<p><strong>margin</strong> : int</p>
<blockquote class="last">
<div><p>The margin to keep outside the widget's border.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.widgets.Widget.add_grid" title="vispy.scene.widgets.Widget.add_grid"><code class="xref py py-obj docutils literal"><span class="pre">add_grid</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Create a new Grid and add it as a child widget.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">add_parent</span></code>(parent)</td>
<td>Add a parent</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.widgets.Widget.add_view" title="vispy.scene.widgets.Widget.add_view"><code class="xref py py-obj docutils literal"><span class="pre">add_view</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Create a new ViewBox and add it as a child widget.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.widgets.Widget.add_widget" title="vispy.scene.widgets.Widget.add_widget"><code class="xref py py-obj docutils literal"><span class="pre">add_widget</span></code></a>(widget)</td>
<td>Add a Widget as a managed child of this Widget.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">common_parent</span></code>(node)</td>
<td>Return the common parent of two entities</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">describe_tree</span></code>([with_transform])</td>
<td>Create tree diagram of children</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#vispy.scene.widgets.Widget.draw" title="vispy.scene.widgets.Widget.draw"><code class="xref py py-obj docutils literal"><span class="pre">draw</span></code></a>(event)</td>
<td>Draw the widget borders</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path</span></code>(node)</td>
<td>Return two lists describing the path from this node to another</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_to_child</span></code>(node)</td>
<td>Return a list describing the path from this node to a child node</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_path_transforms</span></code>(node)</td>
<td>Return the list of transforms along the path to another node.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">node_transform</span></code>(node)</td>
<td>Return the transform that maps from the coordinate system of <em>self</em> to the local coordinate system of <em>node</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.widgets.Widget.on_resize" title="vispy.scene.widgets.Widget.on_resize"><code class="xref py py-obj docutils literal"><span class="pre">on_resize</span></code></a>(event)</td>
<td>On resize handler</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_parent</span></code>(parent)</td>
<td>Remove a parent</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#vispy.scene.widgets.Widget.remove_widget" title="vispy.scene.widgets.Widget.remove_widget"><code class="xref py py-obj docutils literal"><span class="pre">remove_widget</span></code></a>(widget)</td>
<td>Remove a Widget as a managed child of this Widget.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_transform</span></code>(<a href="#id61"><span class="problematic" id="id62">type_</span></a>,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Create a new transform of <em>type</em> and assign it to this node.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Emit an event to inform listeners that properties of this Node or its children have changed.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="vispy.scene.widgets.Widget.add_grid">
<code class="descname">add_grid</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Widget.add_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new Grid and add it as a child widget.</p>
<p>All arguments are given to Grid().</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.widgets.Widget.add_view">
<code class="descname">add_view</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Widget.add_view" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new ViewBox and add it as a child widget.</p>
<p>All arguments are given to ViewBox().</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.widgets.Widget.add_widget">
<code class="descname">add_widget</code><span class="sig-paren">(</span><em>widget</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Widget.add_widget" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a Widget as a managed child of this Widget.</p>
<p>The child will be
automatically positioned and sized to fill the entire space inside
this Widget (unless _update_child_widgets is redefined).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>widget</strong> : instance of Widget</p>
<blockquote>
<div><p>The widget to add.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>widget</strong> : instance of Widget</p>
<blockquote class="last">
<div><p>The widget.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.widgets.Widget.bgcolor">
<code class="descname">bgcolor</code><a class="headerlink" href="#vispy.scene.widgets.Widget.bgcolor" title="Permalink to this definition">¶</a></dt>
<dd><p>The background color of the Widget.</p>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.widgets.Widget.border_color">
<code class="descname">border_color</code><a class="headerlink" href="#vispy.scene.widgets.Widget.border_color" title="Permalink to this definition">¶</a></dt>
<dd><p>The color of the border.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.widgets.Widget.draw">
<code class="descname">draw</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Widget.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw the widget borders</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : instance of Event</p>
<blockquote class="last">
<div><p>The event containing the transforms.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="vispy.scene.widgets.Widget.inner_rect">
<code class="descname">inner_rect</code><a class="headerlink" href="#vispy.scene.widgets.Widget.inner_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>The rectangular area inside the margin, border and padding.</p>
<p>Generally widgets should avoid drawing or placing widgets outside this
rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.widgets.Widget.on_resize">
<code class="descname">on_resize</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Widget.on_resize" title="Permalink to this definition">¶</a></dt>
<dd><p>On resize handler</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : instance of Event</p>
<blockquote class="last">
<div><p>The resize event.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vispy.scene.widgets.Widget.remove_widget">
<code class="descname">remove_widget</code><span class="sig-paren">(</span><em>widget</em><span class="sig-paren">)</span><a class="headerlink" href="#vispy.scene.widgets.Widget.remove_widget" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a Widget as a managed child of this Widget.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>widget</strong> : instance of Widget</p>
<blockquote class="last">
<div><p>The widget to remove.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">

  <div class="container">
    <ul class="list-inline">
      <li><a href="https://github.com/vispy/vispy">GitHub</a></li>
      <li>·</li>
      <li><a href=""><a href="https://github.com/vispy/vispy/blob/master/examples/">Examples</a></li>
      <li>·</li>
      <li><a href="https://github.com/vispy/vispy/issues">Issues</a></li>
      <li>·</li>
      <li><a href="https://github.com/vispy/vispy/releases">Releases</a></li>
      <li class="pull-right"><a href="#">Back to top</a></li>
    </ul>
    <ul class="list-unstyled small">
      <li>Copyright (c) 2015 VisPy developers</li>
      <li>Code licensed under
        <a href="http://opensource.org/licenses/BSD-3-Clause">BSD license</a>,
        documentation under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0 </a>
      </li>
      <li>
        Made with <a href="http://sphinx-doc.org">sphinx</a> using the excellent
        <a href="https://github.com/ryan-roemer/sphinx-bootstrap-theme">bootstrap theme</a>
      </li>
    </ul>
  </div>
</footer>
  </body>
</html>